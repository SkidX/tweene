{"version":3,"sources":["tweene.js","common.js","label.js","callback.js","tween-common.js","timeline-common.js","ticker.js","controls-pro.js","tween-pro.js","timeline-pro.js","tweene-dummy.js","tweene-transit.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5oBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"transit.js","sourcesContent":["/**\n * Tweene - JavaScript Animation Proxy\n * @version 0.5.11\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n/* jshint -W008 */\n\n/**\n * Common data and utility functions used internally.\n * None of them is exported.\n */\n\nif(jQuery && window)\n{\n    var $ = jQuery;\n}\n\n// used for recognize transform properties\nvar transformProperties = 'scale|scale3d|translate|translate3d|rotate|rotate3d|rotation|skew|scaleX|scaleY|scaleZ|translateX|translateY|translateZ|x|y|z|rotateX|rotateY|rotateZ|skewX|skewY'.split('|');\n\n// compound transforms are on the begin of the transformProperties array\nvar compoundTransforms = transformProperties.slice(0, 8);\n\n// compound properties we parse to obtain a list of key - value couples\nvar compoundNames = 'margin|padding|borderColor|borderWidth|borderRadius'.split('|');\nvar compoundDirections = ['Top', 'Right', 'Bottom', 'Left'];\nvar radiusDirections = ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'];\n\n// base name and aliases for event names. Those with an empty string as value are the names used internally\nvar handlersMap = {\n    begin: '',\n    end: '',\n    progress: '',\n    loop: '',\n    reverse: '',\n    onBegin: 'begin',\n    start: 'begin',\n    onStart: 'begin',\n    onEnd: 'end',\n    complete: 'end',\n    onComplete: 'end',\n    finish: 'end',\n    onFinish: 'end',\n    done: 'end',\n    onProgress: 'progress',\n    update: 'progress',\n    onUpdate: 'progress',\n    onLoop: 'loop',\n    onRepeat: 'loop',\n    onReverse: 'reverse',\n    onReverseComplete: 'reverse'\n};\n\n\n// base name and aliases for option names. Those with an empty string as value are the names used internally\nvar optionsMap = {\n    delay: '',\n    loops: '',\n    loopsDelay: '',\n    yoyo: '',\n    target: '',\n    speed: '',\n    sleep: 'delay',\n    repeat: 'loops',\n    repeatDelay: 'loopsDelay',\n    timeScale: 'speed'\n};\n\n\n// base name and aliases for tween option names\nvar tweenOptionsMap = {\n    easing: '',\n    duration: '',\n    paused: '',\n    to: '',\n    from: '',\n    then: '',\n    ease: 'easing'\n};\n\n\n// predefined easing shortcuts\nvar easings = {\n    linear: [.25, .25, .75, .75],\n    ease: [.25, 0.1, 0.25, 1],\n    'ease-in': [.42, 0, 1, 1],\n    'ease-out': [0, 0, .58, 1],\n    'ease-in-out': [.42, 0, .58, 1],\n    'in': [.42, 0, 1, 1],\n    out: [0, 0, .58, 1],\n    'in-out': [.42, 0, .58, 1],\n    snap: [0, 1, .5, 1],\n    easeInCubic: [.550,.055,.675,.190],\n    easeOutCubic: [.215,.61,.355,1],\n    easeInOutCubic: [.645,.045,.355,1],\n    easeInCirc: [.6,.04,.98,.335],\n    easeOutCirc: [.075,.82,.165,1],\n    easeInOutCirc: [.785,.135,.15,.86],\n    easeInExpo: [.95,.05,.795,.035],\n    easeOutExpo: [.19,1,.22,1],\n    easeInOutExpo: [1,0,0,1],\n    easeInQuad: [.55,.085,.68,.53],\n    easeOutQuad: [.25,.46,.45,.94],\n    easeInOutQuad: [.455,.03,.515,.955],\n    easeInQuart: [.895,.03,.685,.22],\n    easeOutQuart: [.165,.84,.44,1],\n    easeInOutQuart: [.77,0,.175,1],\n    easeInQuint: [.755,.05,.855,.06],\n    easeOutQuint: [.23,1,.32,1],\n    easeInOutQuint: [.86,0,.07,1],\n    easeInSine: [.47,0,.745,.715],\n    easeOutSine: [.39,.575,.565,1],\n    easeInOutSine: [.445,.05,.55,.95],\n    easeInBack: [.6,-.28,.735,.045],\n    easeOutBack: [.175, .885,.32,1.275],\n    easeInOutBack: [.68,-.55,.265,1.55]\n};\n\n\n// predefined duration shortcuts\nvar durations = {\n    fast: '200ms',\n    slow: '600ms'\n};\n\n\n// predefined speed shortcuts\nvar speeds = {\n    half: 0.5,\n    'double': 2\n};\n\n\n\nfunction isFunction(value)\n{\n    return typeof value == 'function';\n}\n\n\n\nfunction isNumber(value)\n{\n    return typeof value == 'number' || (value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object Number]') || false;\n}\n\n\n\nfunction isString(value)\n{\n    return typeof value == 'string' || (value && typeof value == 'object' && Object.prototype.toString.call(value) == '[object String]') || false;\n}\n\n\n\nvar isArray = Array.isArray || function(value)\n{\n    return value && typeof value == 'object' && typeof value.length == 'number' && Object.prototype.toString.call(value) == '[object Array]';\n};\n\n\n\nfunction isObject(value)\n{\n    var type = typeof value;\n    return type === 'function' || type === 'object' && !!value;\n}\n\n\n/*\n * @link http://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric\n */\nfunction isNumeric(value)\n{\n    return !isArray(value) && (value - parseFloat(value) + 1) >= 0;\n}\n\n\nfunction isEmpty(obj)\n{\n    for(var name in obj)\n    {\n        if(obj.hasOwnProperty(name))\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n\n\nfunction seemsPlainObject(value)\n{\n    return  isObject(value) && !(value instanceof Function) && value.constructor == Object;\n}\n\n\n\nfunction extendObject(obj)\n{\n    if (!isObject(obj))\n    {\n        return obj;\n    }\n\n    var source, name, i, length;\n    for (i = 1, length = arguments.length; i < length; i++)\n    {\n        source = arguments[i];\n        for (name in source)\n        {\n            obj[name] = source[name];\n        }\n    }\n    return obj;\n}\n\n\nfunction cloneObject(obj, deep)\n{\n    if (isFunction(obj) || !isObject(obj))\n    {\n        return obj;\n    }\n    if(isArray(obj))\n    {\n        obj = obj.slice();\n        if(deep)\n        {\n            for(var i = 0, end = obj.length; i < end; i++)\n            {\n                obj[i] = cloneObject(obj[i], deep);\n            }\n        }\n    }\n    else\n    {\n        obj = extendObject({}, obj);\n        if(deep)\n        {\n            for(var name in obj)\n            {\n                if(obj.hasOwnProperty(name))\n                {\n                    obj[name] = cloneObject(obj[name], deep);\n                }\n            }\n        }\n    }\n\n    return obj;\n}\n\n\n\nfunction keys(obj)\n{\n    if(Object.keys)\n    {\n        return Object.keys(obj);\n    }\n    var ks = [];\n    for (var key in obj)\n    {\n        if(obj.hasOwnProperty(key))\n        {\n            ks.push(key);\n        }\n    }\n    return ks;\n}\n\n\n// simplified version of Array.indexOf polyfill\nfunction inArray(array, search)\n{\n    if(!isArray(array))\n    {\n        throw 'expected an array as first param';\n    }\n\n    if(array.indexOf)\n    {\n        return array.indexOf(search);\n    }\n\n    for(var i = 0, end = array.length; i < end; i++)\n    {\n        if(array[i] === search)\n        {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n// used to convert arguments to real array\nfunction toArray(args, pos)\n{\n    if(pos === void 0)\n    {\n        pos = 0;\n    }\n    return Array.prototype.slice.call(args, pos);\n}\n\n\n/**\n * convert time from seconds to milliseconds and vice versa\n *\n * @param {number} value\n * @param {string} fromUnit - 's' | 'ms'\n * @param {string} toUnit - 's' | 'ms'\n * @returns {Number}\n */\nfunction convertTime(value, fromUnit, toUnit)\n{\n    if(fromUnit != toUnit && value !== 0)\n    {\n        return value * (toUnit == 's'? 0.001 : 1000);\n    }\n    return value;\n}\n\n\n\n/*\n *  Based on Bez http://github.com/rdallasgray/bez\n *\n * Copyright Robert Dallas Gray. All rights reserved.\n * Provided under the FreeBSD license: https://github.com/rdallasgray/bez/blob/master/LICENSE.txt\n*/\nfunction bezier(x1, y1, x2, y2)\n{\n    var p1 = [x1, y1], p2 = [x2, y2],\n        A = [null, null], B = [null, null], C = [null, null],\n\n        bezCoOrd = function(time, ax)\n        {\n            C[ax] = 3 * p1[ax]; B[ax] = 3 * (p2[ax] - p1[ax]) - C[ax]; A[ax] = 1 - C[ax] - B[ax];\n            return time * (C[ax] + time * (B[ax] + time * A[ax]));\n        },\n\n        xDeriv = function(time)\n        {\n            return C[0] + time * (2 * B[0] + 3 * A[0] * time);\n        },\n\n        xForT = function(time)\n        {\n            var x = time, i = 0, z;\n            while (++i < 14)\n            {\n                z = bezCoOrd(x, 0) - time;\n                if (Math.abs(z) < 1e-3) break;\n                x -= z / xDeriv(x);\n            }\n            return x;\n        };\n\n    return function(time) {\n        return bezCoOrd(xForT(time), 1);\n    };\n}\n\n\n/**\n * take as input compound properties defined as a space separated string of values and return the list of single value properties\n *\n *   padding: 5 => paddingTop: 5, paddingRight: 5, paddingBottom: 5, paddingLeft: 5\n *   border-width: 2px 1px => borderTopWidth: 2px, borderRightWidth: 1px, borderBottomWidth: 2px, borderLeftWidth: 1px\n *\n * @param {string} name\n * @param {string} value\n * @returns {object}\n */\nfunction compoundMapping(name, value)\n{\n    var parts, nameParts, prefix, suffix, dirs, values = {}, easing, i;\n    if(isArray(value))\n    {\n        value = value[0];\n        easing = value[1];\n    }\n    else\n    {\n        easing = null;\n    }\n\n    parts = String(value).split(/\\s+/);\n\n    switch(parts.length)\n    {\n        case 1: parts = [parts[0], parts[0], parts[0], parts[0]]; break;\n        case 2: parts = [parts[0], parts[1], parts[0], parts[1]]; break;\n        case 3: parts = [parts[0], parts[1], parts[2], parts[1]]; break;\n    }\n\n    nameParts = decamelize(name).split('-');\n    prefix = nameParts[0];\n    suffix = nameParts.length > 1? nameParts[1].substr(0, 1).toUpperCase() + nameParts[1].substr(1) : '';\n\n    dirs = name == 'borderRadius'? radiusDirections : compoundDirections;\n\n    for(i = 0; i < 4; i++)\n    {\n        values[prefix + dirs[i] + suffix] = easing? [parts[i], easing] : parts[i];\n    }\n    return values;\n}\n\n\n/**\n *  split commpound transform values\n *\n *   scale: 1.2 => scaleX: 1.2, scaleY: 1.2\n *   rotate3d: 30, 60, 40 => rotateX: 30, rotateY: 60, rotateZ: 40\n *\n * @param {string} name\n * @param {string} value\n * @returns {object}\n */\nfunction transformMapping(name, value)\n{\n    var easing, dirs = ['X', 'Y', 'Z'], values = {}, parts, baseName;\n    if(isArray(value))\n    {\n        value = value[0];\n        easing = value[1];\n    }\n    else\n    {\n        easing = null;\n    }\n\n    parts = String(value).split(/\\s*,\\s*/);\n    baseName = name.indexOf('3') !== -1? name.substr(0, name.length - 2) : name;\n\n    if(name == 'rotate3d')\n    {\n        if(parts.length == 4)\n        {\n            dirs = [parts[0] == '1'? 'X' : (parts[1] == '1'? 'Y' : 'Z')];\n            parts[0] = parts[3];\n        }\n        else\n        {\n            throw 'invalid rotate 3d value';\n        }\n    }\n    else\n    {\n        switch(parts.length)\n        {\n            // for rotations, a single value is passed as Z-value, while for other transforms it is applied to X and Y\n            case 1:\n                parts = baseName == 'rotate' || baseName == 'rotation'? [null, null, parts[0]] : [parts[0], parts[0], null];\n            break;\n\n            case 2:\n                parts = [parts[0], parts[1], null];\n            break;\n        }\n\n    }\n\n    for(var i = 0; i < dirs.length; i++)\n    {\n        if(parts[i] !== null)\n        {\n            values[baseName + dirs[i]] = easing? [parts[i], easing] : parts[i];\n        }\n    }\n    return values;\n}\n\n\n\nfunction isTransformProperty(name)\n{\n    return (inArray(transformProperties, name) != -1);\n}\n\n\n// border-bottom-width -> borderBottomWidth\nfunction camelize(name)\n{\n    return name.replace(/(\\-[a-z])/g, function(value) {\n        return value.substr(1).toUpperCase();\n    });\n}\n\n\n// borderBottomWidth -> border-bottom-width\nfunction decamelize(name)\n{\n    return name.replace(/([A-Z])/g, '-$1').toLowerCase();\n}\n\n\n/**\n * accept a speed name shortcuts or a number and give back an acceptable positive value.\n * Fallback to 1 if value is out of valid range\n *\n * @param {string|number} value\n * @returns {number}\n */\nfunction parseSpeed(value)\n{\n    if(value in speeds)\n    {\n        value = speeds[value];\n    }\n\n    value = parseFloat(value);\n    if(isNaN(value) || !value || value <= 0)\n    {\n        value = 1;\n    }\n    return value;\n}\n\n\n\n\n/**\n * Tweene global class, is the unique identifier exported\n *\n * You will never need to instantiate a Tweene object. You have to use Tweene static methods\n * in order to obtain instances of tween and timeline objects of the different drivers\n *\n * @class\n *\n */\nvar Tweene = function()\n{\n    var _self = this;\n\n    // used for generate unique identifier for any tweene object (tweens, timelines, callbacks and labels)\n    this._idCounter = 0;\n\n    // internally, all time values use this unit\n    this._coreTimeUnit = 'ms';\n\n    // time unit used when pure numbers are passed as delay or duration values. Users can change this value any time\n    // when the user requires only GSAP driver, it defaults to 's' in order to mimic the library native API\n    this.defaultTimeUnit = 'ms';\n\n    this._macros = {};\n\n    this.easings = easings;\n\n    this.durations = durations;\n\n    this.speeds = speeds;\n\n    this.defaultDriver = 'jquery';\n\n    this.defaultEasing = 'easeOutQuad';\n\n    this.defaultDuration = '400ms';\n\n    // container for registered drivers\n    var _drivers = {\n            tween: {},\n            timeline: {}\n        },\n\n\n        /**\n         * Create a tween or timeline object of the specified driver. If driverName is not given, it fallbacks to default driver\n         *\n         * @param {string} 'tween' or 'timeline'\n         * @param {string} [driverName] - one of the registered driver's name\n         * @returns {object} tween or timeline object\n         */\n        _getInstance = function(type, driverName)\n        {\n            var d, i;\n            driverName = (driverName? driverName : _self.defaultDriver).toLowerCase();\n\n            if(driverName in _drivers[type])\n            {\n                d = _drivers[type][driverName];\n                i = new d();\n                i.driverName = driverName;\n                return i;\n            }\n            throw 'Driver ' + name + ' not found';\n        },\n\n\n        /**\n         * Common method used inside from(), to() and fromTo() to create a tween and pass arguments to it\n         *\n         * @param {arguments} args - list of arguments passed to original public method\n         * @param {string} method - 'from' | 'to' | 'fromTo'\n         * @returns {object} - return a tween object\n         */\n        _tweenNow = function(args, method)\n        {\n            var tw = _getInstance('tween');\n            if(args.length)\n            {\n                args = toArray(args, 0);\n                tw.target(args.shift())[method].apply(tw, args);\n            }\n\n            return tw._immediateStart? tw.play() : tw;\n        };\n\n\n    /**\n     * Register an animation driver\n     *\n     * @param {string} name - name of the driver\n     * @param {string} type - 'tween' | 'timeline'\n     * @param {function} construct - constructor function that defines the driver class\n     * @returns {Tweene}\n     */\n    this.registerDriver = function(name, type, construct)\n    {\n        type = type.toLowerCase();\n        if(type != 'tween')\n        {\n            type = 'timeline';\n        }\n        _drivers[type][name.toLowerCase()] = construct;\n        return this;\n    };\n\n\n    /**\n     * Define a macro for tween objects\n     * @link http://tweene.com/docs/#macro\n     *\n     * @param {string} name\n     * @param {function} macro - inside the function, 'this' refers to the tween object\n     * @returns {Tweene}\n     */\n    this.registerMacro = function(name, macro)\n    {\n        this._macros[name] = macro;\n        return this;\n    };\n\n\n    /**\n     * Return an instance of a tween object\n     * @link http://tweene.com/docs/#createTween\n     *\n     * @param {object|string} [target] jquery object or string selector of the dom element(s) to be animated\n     * @param {string} [driver]\n     * @returns {object}\n     */\n    this.get = function(target, driver)\n    {\n        var t = _getInstance('tween', driver);\n        return target? t.target(target) : t;\n    };\n\n\n    /**\n     * Apply instantly the properties values to the target\n     *\n     * @param {object|string} target\n     * @param {object} values - CSS property - value map\n     * @returns {unresolved}\n     */\n    this.set = function(target, values)\n    {\n        return _getInstance('tween').target(target).set(values);\n    };\n\n\n    /**\n     * Create a tween object for a 'to' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenTo\n     *\n     * @returns {object} - return the tween object\n     */\n    this.to = function()\n    {\n        return _tweenNow(arguments, 'to');\n    };\n\n\n    /**\n     * Create a tween object for a 'from' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenFrom\n     *\n     * @returns {object} - return the tween object\n     */\n    this.from = function()\n    {\n        return _tweenNow(arguments, 'from');\n    };\n\n\n    /**\n     * Create a tween object for a 'fromTo' animation and pass the arguments to it. First argument is always the target.\n     * If you don't set paused: true in the options passed, the tween will start immediately.\n     * @link http://tweene.com/docs/#tweenFromTo\n     *\n     * @returns {object} - return the tween object\n     */\n    this.fromTo = function()\n    {\n        return _tweenNow(arguments, 'fromTo');\n    };\n\n\n    /**\n     * Create a timeline object\n     * @link http://tweene.com/docs/#createTimeline\n     *\n     * @param {object|string} [target] - it checks if the object passed as first param is a plain object (options) or not (target)\n     * @param {object} [options]\n     * @param {string} driver - name of the driver\n     * @returns {object} - a timeline object\n     */\n    this.line = function(target, options, driver)\n    {\n        // we assume that targets cannot be plain objects\n        var lineTarget = (isObject(target) && !seemsPlainObject(target))  || isString(target)? target : null;\n        // if no target is passed, unshift arguments by one position\n        if(!lineTarget)\n        {\n            options = arguments[0];\n            driver = arguments[1];\n        }\n        options = seemsPlainObject(options)? options : {};\n        // driver can be specified also with a 'driver' property inside options object\n        driver = (driver !== void 0)? driver : 'driver' in options? options.driver : null;\n        return _getInstance('timeline', driver)\n            .options(options)\n            .target(lineTarget);\n    };\n\n};\n\nvar Tw = new Tweene();\n\nif(window)\n{\n    window.Tweene = Tw;\n}\n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods common to every tween and timeline, whatever is the driver used\n * @mixin\n *\n */\nvar Common = function()\n{\n    // unique identifier\n    this._id = ++ Tw._idCounter;\n    this._coreTimeUnit = Tw._coreTimeUnit;\n    this._timeUnit = Tw.defaultTimeUnit;\n\n    this._parent = null;\n\n    this._target = null;\n\n    this._duration = 0;\n\n    this._speed = 1;\n\n    this._delay = 0;\n\n    this._loops = 0;\n\n    this._loopsDelay = 0;\n\n    this._loopsCount = 0;\n\n    this._yoyo = false;\n\n    this._fwd = true;\n\n    this._localFwd = true;\n\n    this._ready = false;\n\n    this._running = false;\n\n    // event handlers set by user\n    this._handlers = {\n        begin: null,\n        end: null,\n        reverse: null,\n        progress: null,\n        loop: null\n    };\n\n    // event handlers set internally\n    this._coreHandlers = {\n        _begin: [],\n        _end: [],\n        begin: [],\n        end: [],\n        reverse: [],\n        progress: [],\n        loop : []\n    };\n\n\n    /**\n     * Play the animation in forward direction\n     * @link http://tweene.com/docs/#play\n     *\n     * @returns {this}\n     */\n    this.play = function()\n    {\n        this._fwd = true;\n        this._playTween();\n        return this;\n    };\n\n\n    /**\n     * Play the animation in backward direction from its current position\n     * @link http://tweene.com/docs/#reverse\n     *\n     * @returns {this}\n     */\n    this.reverse = function()\n    {\n        this._fwd = false;\n        this._reverseTween();\n        return this;\n    };\n\n\n    /**\n     * Pause the animation on its current state.\n     * @link http://tweene.com/docs/#pause\n     *\n     * @returns {this}\n     */\n    this.pause = function()\n    {\n        if(this._ready)\n        {\n            this._pauseTween();\n        }\n        return this;\n    };\n\n\n    /**\n     * Resume a previously paused animation without affecting the current direction\n     * @link http://tweene.com/docs/#resume\n     *\n     * @returns {this}\n     */\n    this.resume = function()\n    {\n        this._resumeTween();\n        return this;\n    };\n\n\n    /**\n     * Restart animation in forward direction.\n     * Reset also loops counter.\n     * Initial delay is performed only on the very first start, not on restart.\n     * @link http://tweene.com/docs/#restart\n     *\n     * @returns {this}\n     */\n    this.restart = function()\n    {\n        this._restartTween();\n        return this;\n    };\n\n\n    /**\n     * Go back to initial or final position accordingly to the value of direction. Intended to be used internally, you don't have to call this directly.\n     *\n     * @returns {this}\n     */\n    this.back = function()\n    {\n        this._backTween(this._localFwd? 'begin' : 'end');\n        return this;\n    };\n\n\n    /**\n     * Get or set the speed of the current tween/timeline. Normal speed is 1, so 2 is double speed and 0.5 is half speed.\n     * It's usable both before and during the animation.\n     * It Accepts also string shortcut defined in Tweene.speeds\n     * @link http://tweene.com/docs/#speedControl\n     *\n     * @param {number} [value]\n     * @returns {number|this}\n     */\n    this.speed = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._speed;\n        }\n\n        value = parseSpeed(value);\n        if(value != this._speed)\n        {\n            this._speed = value;\n            this._speedTween();\n        }\n        return this;\n    };\n\n\n    /**\n     * Alias for speed()\n     * @see speed\n     *\n     */\n    this.timeScale = function()\n    {\n        return this.speed.apply(this, arguments);\n    };\n\n\n    /**\n     * Return the current playhead time (a value between 0 and duration) in time unit set in Tweene.defaultTimeUnit\n     *\n     * @returns {number}\n     */\n    this.time = function()\n    {\n        return Math.round(convertTime(this._getPosition(), this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Return the current playhead position in percent (a value between 0 and 1)\n     *\n     * @returns {number}\n     */\n    this.progress = function()\n    {\n        return Math.round(this._getProgress() * 1000) / 1000;\n    };\n\n\n    /**\n     * Return true if the animation is currently paused\n     * Tt's true also when the animation is finished or not yet started\n     *\n     * @returns {boolean}\n     */\n    this.paused = function()\n    {\n        return this._getPaused();\n    };\n\n\n    /**\n     * Return true if the animation direction is currently reversed\n     *\n     * @returns {boolean}\n     */\n    this.reversed = function()\n    {\n        return !this._fwd;\n    };\n\n\n    /**\n     * Get/Set the tween duration (only get available for timeline)\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     *\n     * @param {string|number} [value]\n     * @returns {this|number}\n     *\n     */\n    this.duration = function(value)\n    {\n        if(value !== void 0)\n        {\n            if(this._type != 'timeline')\n            {\n                this._duration = this._parseTime(value);\n                this.invalidate();\n            }\n            return this;\n        }\n\n        // timeline needs to process its children in order to calculate the overall duration\n        if(this.type == 'timeline')\n        {\n            this.prepare();\n        }\n        return Math.round(convertTime(this._duration, this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Get the tween/timeline total duration including loops and loopsDelay, in the timeUnit set in Tweene.defaultTimeUnit\n     * In case of infinite loop, it returns Infinity\n     *\n     * @returns {number}\n     */\n    this.totalDuration = function()\n    {\n        if(this.type == 'timeline')\n        {\n            this.prepare();\n        }\n        return Math.round(convertTime(this._getTotalDuration() * this._speed, this._coreTimeUnit, this._timeUnit) * 1000) / 1000;\n    };\n\n\n    /**\n     * Set the animation target (jquery or dom objects commonly, accordingly to the specific animation library in use)\n     * @link http://tweene.com/docs/#target\n     *\n     * @param {string|object} [value]\n     * @returns {string|object|this}\n     */\n    this.target = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._target;\n        }\n        this._setTarget(value);\n        return this;\n    };\n\n\n    /**\n     * Get/Set the tween initial delay\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     * @link http://tweene.com/docs/#delay\n     *\n     * @param {string|number} [value]\n     * @returns {number|this}\n     */\n    this.delay = function(value)\n    {\n        if(value === void 0)\n        {\n            return convertTime(this._delay, this._coreTimeUnit, this._timeUnit);\n        }\n        this._delay = this._parseTime(value);\n        this.invalidate();\n        return this;\n    };\n\n\n\n    /**\n     * Set the number of animation repeats. Default is 0, so loops(1) will execute the tween/timeline twice.\n     * A value of -1 means 'Infinite loop'.\n     * @link http://tweene.com/docs/#loops\n     *\n     * @param {number} value\n     * @returns {this}\n     */\n    this.loops = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._loops;\n        }\n        value = parseInt(value);\n        if(isNaN(value))\n        {\n            value = 0;\n        }\n        else if(!isFinite(value))\n        {\n            value = -1;\n        }\n        this._loops = value;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Enable/disable yoyo behavior or retrieve its status.\n     * Yoyo makes sense only when used with looops.\n     * @link http://tweene.com/docs/#yoyoEffect\n     *\n     * @param {boolean} [value]\n     * @returns {boolean|this}\n     */\n    this.yoyo = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._yoyo;\n        }\n        this._yoyo = !!value;\n        return this;\n    };\n\n\n    /**\n     * Get/Set the value of delay before each loop iteration\n     * Accept numeric values interpreted as Tweene.defaultTimeUnit\n     * or string with unit suffix, so '500ms' or '0.5s'\n     * @link http://tweene.com/docs/#loopsDelay\n     *\n     * @param {string|number} [value]\n     * @returns {number|this}\n     */\n    this.loopsDelay = function(value)\n    {\n        if(value === void 0)\n        {\n            return convertTime(this._loopsDelay, this._coreTimeUnit, this._timeUnit);\n        }\n        this._loopsDelay = this._parseTime(value);\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Add event handler.\n     * First param is the event name,\n     * second param is the callback function,\n     * third (optional) array of params to pass to the callback\n     * fourth (optional) scope for the callback (the default is the tween / timeline object that will raise the event)\n     *\n     * Available events:\n     *  begin | onBegin | start | onStart:\n     *      raised on the animation start\n     *\n     *  end | onEnd | complete | onComplete | finish | onFinish | done:\n     *      raised on the animation end, after all loops (a tween with infinite loops will never fire this event)\n     *\n     *  reverse | onReverse | onReverseComplete:\n     *      raised when the animation ends in backward direction, so at the start position.\n     *\n     *  progress | onProgress | update | onUpdate:\n     *      fires periodically during the tween. The frequency of the call\n     *      could be different for any animation library used.\n     *      When the library does not offer native progress event, it is emulated\n     *      via RequestAnimationFrame\n     *\n     *  loop | onLoop | onRepeat:\n     *      raised on each loop iteration\n     *\n     *\n     * @link http://tweene.com/docs/#events\n     *\n     * @param {string} name\n     * @param {function|null} callback - pass null to remove a previously set event handler\n     * @param {array} [params]\n     * @param {object} [scope]\n     * @returns {this}\n     */\n    this.on = function(name, callback)\n    {\n        if(name in handlersMap)\n        {\n            name = handlersMap[name].length? handlersMap[name] : name;\n            if(callback === null)\n            {\n                this._handlers[name] = null;\n            }\n            else\n            {\n                this._handlers[name] = {\n                    callback: callback,\n                    params: arguments.length > 2? (isArray(arguments[2])? arguments[2] : [arguments[2]]) : [],\n                    scope: arguments.length > 3 && arguments[3] !== null? arguments[3] : this\n                };\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Used internally for register core event handlers\n     *\n     * @param {string} name\n     * @param {string} id\n     * @param {function} callback\n     * @param {object} [scope]\n     * @param {array} [params]\n     * @param {boolean} [priority]\n     * @returns {this}\n     */\n    this.setCoreHandler = function(name, id, callback, scope, params, priority)\n    {\n        this.unsetCoreHandler(name, id);\n        var entry = {id: id, callback: callback, scope: scope || this, params: params || []};\n\n        if(priority)\n        {\n            this._coreHandlers[name].unshift(entry);\n        }\n        else\n        {\n            this._coreHandlers[name].push(entry);\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Used internally for unregister core event handlers\n     *\n     * @param {string} name\n     * @param {string} id\n     * @returns {this}\n     */\n    this.unsetCoreHandler = function(name, id)\n    {\n        for(var i = 0, end = this._coreHandlers[name].length; i < end; i++)\n        {\n            if(this._coreHandlers[name][i].id == id)\n            {\n                this._coreHandlers[name].splice(i, 1);\n                break;\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Reset _ready flag every time that one of the internal properties that need to be processed before running is changed\n     *\n     * @returns {this}\n     */\n    this.invalidate = function()\n    {\n        if(!this._running)\n        {\n            if(this._parent)\n            {\n                this._parent.invalidate();\n            }\n            this._ready = false;\n        }\n        return this;\n    };\n\n\n    /**\n     * Get/Set the parent object. The parent could be a timeline or a tween if the child is a DummyTween used for emulate delay\n     *\n     * @param {object} [value]\n     * @returns {this|object}\n     */\n    this.parent = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._parent;\n        }\n        this._parent = value;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Get the internal unique identifier\n     *\n     * @returns {number}\n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n\n\n    /**\n     * Set options for tween or timeline\n     *\n     * @param {object} options\n     * @returns {this}\n     */\n    this.options = function(options)\n    {\n        // the object will be modified, we need to clone it in order to keep the original safe, allowing its reuse\n        options = cloneObject(options, true);\n        var opts = this._parseOptions(options);\n        opts.events = this._parseEvents(options);\n        this._applyArguments(opts);\n        return this;\n    };\n\n\n    /**\n     * Return the resulting speed of the object\n     *\n     * @returns {number}\n     */\n    this.getRealSpeed = function()\n    {\n        return this._parent? this._parent.getRealSpeed() * this._speed : this._speed;\n    };\n\n\n    /**\n     * Get the tween/timeline total duration including loops and loopsDelay\n     * In case of infinite loop, it returns Infinity\n     *\n     * @returns {number}\n     */\n    this._getTotalDuration = function()\n    {\n        if(this._loops == -1 && (this._duration || this._loopsDelay))\n        {\n            return Infinity;\n        }\n        return (this._duration + ((this._loopsDelay + this._duration) * this._loops)) / this._speed;\n    };\n\n\n    /**\n     * Assign otpions and event handlers previously parsed\n     *\n     * @param {object} args\n     */\n    this._applyArguments = function(args)\n    {\n        var name;\n        for(name in args.events)\n        {\n            this.on.apply(this, args.events[name]);\n        }\n        delete args.events;\n\n        for(name in args)\n        {\n            // these properties are available only for tween objects\n            if(this.type != 'timeline' && inArray(['from', 'to', 'then', 'immediateStart'], name) != -1)\n            {\n                this['_' + name] = args[name];\n            }\n            else if(name in this && this[name] instanceof Function)\n            {\n                this[name](args[name]);\n            }\n        }\n    };\n\n\n    /**\n     * Check if there are public or internal event handlers set for that name\n     *\n     * @param {string} name\n     * @returns {boolean}\n     */\n    this._hasHandlers = function(name)\n    {\n        return (name in this._handlers && this._handlers[name] !== null) || this._coreHandlers[name].length;\n    };\n\n\n    /**\n     * execute event handlers bound to the given name\n     *\n     * @param {string} name\n     */\n    this._runHandlers = function(name)\n    {\n        var i, end, entry;\n\n        // run external events first to guarantee correct events order inside timelines\n        if(name in this._handlers && this._handlers[name] !== null)\n        {\n            entry = this._handlers[name];\n            entry.callback.apply(entry.scope, entry.params);\n        }\n\n        // internal handlers\n        if(this._coreHandlers[name].length)\n        {\n            for(i = 0, end = this._coreHandlers[name].length; i < end; i++)\n            {\n\n                entry = this._coreHandlers[name][i];\n                entry.callback.apply(entry.scope, entry.params);\n            }\n        }\n\n    };\n\n\n\n\n    /**\n     * find and return allowed options in a generic object\n     *\n     * @param {Object} options\n     * @param {Boolean} remove - if true, it removes found options from original object\n     * @returns {Object}\n     */\n    this._parseOptions = function(options, remove)\n    {\n        var opts = this.type == 'tween'? extendObject({}, optionsMap, tweenOptionsMap) : optionsMap,\n            values = {}, name, realName, value;\n\n        for(name in options)\n        {\n            if(options.hasOwnProperty(name) && name in opts)\n            {\n                value = options[name];\n                // paused property is used internally for another purpose, so we have to handle this option separately\n                if(name == 'paused')\n                {\n                    this._immediateStart = !value;\n                    delete options[name];\n                    continue;\n                }\n\n                realName = opts[name].length? opts[name] : name;\n                values[realName] = value;\n                if(remove)\n                {\n                    delete options[name];\n                }\n\n            }\n        }\n        return values;\n    };\n\n\n\n    /**\n     * Find and return allowed event in a generic object\n     *\n     * @param {object} options\n     * @param {boolean} remove - if true, it removes found handlers and related values (scope and params) from original object\n     * @returns {object}\n     */\n    this._parseEvents = function (options, remove)\n    {\n        var values = {}, value, args, name, realName, params;\n        for(name in options)\n        {\n            if(options.hasOwnProperty(name) && name in handlersMap)\n            {\n                value = options[name];\n                realName = handlersMap[name].length? handlersMap[name] : name;\n                args = [realName, value];\n                if(remove)\n                {\n                    delete options[name];\n                }\n                if((name + 'Params') in options)\n                {\n                    params = options[name + 'Params'];\n                    args.push(isArray(params) ? params : [params]);\n                    if(remove)\n                    {\n                        delete options[name + 'Params'];\n                    }\n                }\n                if((name + 'Scope') in options)\n                {\n                    args.push(options[name + 'Scope']);\n                    if(remove)\n                    {\n                        delete options[name + 'Scope'];\n                    }\n                }\n                else\n                {\n                    args.push(this);\n                }\n                values[realName] = args;\n            }\n        }\n        return values;\n    };\n\n\n    /**\n     * Parse time value used for delay and duration settings, return a number that is the time expressed in coreTimeUnit.\n     * Fallback to 0 if the given value is not valid\n     *\n     * @param {string|number} value\n     * @returns {number}\n     */\n    this._parseTime = function(value)\n    {\n        if(!value)\n        {\n            return 0;\n        }\n        var unit = this._timeUnit, parts;\n        if(isString(value))\n        {\n            // check for duration shortcuts like 'slow', 'fast', and so on\n            if(value in durations)\n            {\n                value = durations[value];\n            }\n\n            // accept 's' or 'ms' as suffix after the number\n            parts = value.match(/^[\\+\\-]?\\s*([0-9\\.]+)\\s*(m?s)?$/i);\n            if(parts === null || parts[1] === void 0)\n            {\n                return 0;\n            }\n            if(parts[2] !== void 0)\n            {\n                unit = parts[2].toLowerCase();\n            }\n            value = parts[1];\n        }\n        value = Number(value);\n\n        if(isNaN(value))\n        {\n            value = 0;\n        }\n\n        value = convertTime(value, unit, this._coreTimeUnit);\n\n        return Math.max(0, value);\n    };\n\n\n    /**\n     * Set the target for tween or timeline. It accept both an object or a selector string\n     *\n     * @param {string|object} value\n     * @returns {this}\n     */\n    this._setTarget = function(value)\n    {\n        if(isString(value) && '$' in window)\n        {\n            value = $(value);\n        }\n        this._target = value;\n        return this;\n    };\n\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n/**\n * Create a Label object, used internally by timelines when you add a label\n * @class\n *\n * @param {string} name\n */\nvar Label = function(name)\n{\n    this.type = 'label';\n    this._id = name;\n    this._name = name;\n    this._position = null;\n\n\n    /**\n     * Return the unique identifier\n     *\n     * @returns {number}\n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n\n\n    /**\n     * Get/Set the time position inside the parent timeline\n     *\n     * @param {number} [value]\n     * @returns {this}\n     */\n    this.position = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._position;\n        }\n        this._position = value;\n        return this;\n    };\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Create a Callback object, used internally by timelines when you add callbacks calls\n * @class\n * \n * @param {function} callback\n * @param {object} scope\n * @param {array} params\n * @param {number} dir - values: 1 | -1 | 0\n */\nvar Callback = function(callback, scope, params, dir, isPause)\n{\n    this.type = 'callback';    \n    // unique id\n    this._id = ++ Tw._idCounter;\n    \n    this.isPause = !!isPause;\n    \n    dir = dir === 1? true : (dir === -1? false : null);\n    var parent = null;\n            \n    /**\n     * Get or set the parent timeline object\n     * \n     * @param {object} [value] - parent object\n     * @returns {object|this}\n     */\n    this.parent = function(value)\n    {\n        if(!value)\n        {\n            return parent;\n        }\n        parent = value;\n        return this;                \n    };\n    \n    \n    /**\n     * Return the unique identifier\n     * \n     * @returns {number} \n     */\n    this.id = function()\n    {\n        return this._id;\n    };\n    \n    \n    /**\n     * Duration of a callback inside a timeline is always 0, this is needed because internally they are handled as tweens\n     * \n     * @returns {number}\n     */\n    this.totalDuration = function()\n    {\n        return 0;\n    };\n    \n        \n    /**\n     * Execute the callback if the parent's direction is coherent with the callback's dir value\n     * \n     * @returns {this}\n     */\n    this.resume = function()\n    {\n        if(callback && (dir === null || dir != parent.reversed()))\n        {\n            callback.apply(scope || parent, params);\n        }\n        return this;\n    };\n    \n    \n    \n};\n\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Vars and methods common to every tween, whatever is the driver used\n * @mixin\n * \n */\nvar TweenCommon = function()\n{    \n    this.type = 'tween';\n\n    this._from = null;\n\n    this._to = null;\n\n    this._then = null;\n\n    this._easing = Tw.defaultEasing;\n\n    this._duration = this._parseTime(Tw.defaultDuration);\n\n    // could be overriden inside each driver\n    this._propertyMap = {};\n\n    this._hasMultipleEasing = false;\n    this._allowMultipleEasing = false;\n    this._allowTransform = false;        \n\n    this._immediateStart = true;                \n\n    this._data = null;    \n\n    this._offset = 0;\n\n\n\n    /**\n     * Used by parent timeline to set the time offset of the tween\n     * \n     * @param {number} value\n     * @returns {this}\n     */\n    this.offset = function(value)\n    {\n        this._offset = value;\n        return this;\n    };\n\n\n    /**\n     * Create and return a timeline using target and driver of the current object\n     * \n     * @param {object} params\n     * @returns {object}\n     */\n    this.line = function(params)\n    {\n        return Tw.line(this._target, params, this.driverName);\n    };\n\n\n    /**\n     * Execute a previously registered macro using this as macro scope\n     * \n     * @param {string} name - the name of the macro\n     * @returns {this}\n     */\n    this.exec = function(name)\n    {\n        // all arguments but the first will be passed to the macro\n        var args = toArray(arguments, 1);\n        if(name && name in Tw._macros)\n        {\n            Tw._macros[name].apply(this, args);\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Get/Set an easing function for the tween\n     * \n     * @param {string|array} [value] You could pass a string shortcut for easing registered in Tweene.easings or a 4-length array that represents \n     * a cubic bezier curve\n     * @returns {string|array|this}\n     */\n    this.easing = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._easing;\n        }            \n        this._easing = value;\n        return this;\n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"from\" style properties\n     * \n     * @returns {this}\n     */\n    this.from = function()\n    {\n        this.parseArguments(arguments, true, false);        \n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"from\" style properties and another one considered as \"to\" style properties\n     * \n     * @returns {this}\n     */\n    this.fromTo = function()\n    {\n        this.parseArguments(arguments, true, true);        \n        this.invalidate();\n        return this; \n    };\n\n\n    /**\n     * Parse arguments and set internal properties, expecting an object considered as \"to\" style properties\n     * \n     * @returns {this}\n     */\n    this.to = function()\n    {\n        this.parseArguments(arguments, false, true);        \n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Set then style properties\n     * @link http://tweene.com/docs/#then\n     * \n     * @param {object} values\n     * @returns {this}\n     */\n    this.then = function(values)\n    {\n        this._then = values;\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Change style properties instantly, like $('#target').css()\n     * @link http://tweene.com/docs/#tweenSet\n     * \n     * @param {object} values\n     * @returns {this}\n     */\n    this.set = function(values)\n    {\n        // it runs as a 'to' tween with 0 duration, this allow to schedule it inside a timeline too\n        if(values)\n        {\n            this._to = values;        \n        }\n        this\n            .duration(0)\n            .play();\n        return this;\n    };\n\n\n    /**\n     * Perform internal tasks needed before starting the tween\n     * \n     * @returns {number} - Returns the tween total duration\n     */\n    this.prepare = function()\n    {\n        this._prepare();\n        return this._getTotalDuration();\n    };\n\n\n    /**\n     * Parse all the supported variants for argument syntax in Tweene.to, Tweene.from and Tweene.fromTo. Check docs:\n     * @link http://tweene.com/docs/#tweenTo\n     * @link http://tweene.com/docs/#tweenFrom\n     * @link http://tweene.com/docs/#tweenFromTo\n     * \n     * @param {arguments|array} args\n     * @param {boolean} needFrom\n     * @param {boolean} needTo\n     * @param {boolean} needPos - using timeline shortcuts .to() .from() and .fromTo() also position inside the timeline need to be parsed from arguments\n     * @returns {string|number|this} - if needPos = true, returns parsed position\n     */\n    this.parseArguments = function(args, needFrom, needTo, needPos)\n    {\n        if(!isArray(args))\n        {\n            args = toArray(args);\n        }\n        var values = {events: {}}, pos = null;        \n        if(args.length)\n        {\n            // duration passed before properties, like in GSAP\n            if(isString(args[0]) || isNumber(args[0]))\n            {\n                values.duration = args.shift();\n            }\n\n            if(args.length)\n            {\n                if(needFrom)\n                {\n                    values = this._parseDataArg(args.shift(), 'from', values);\n                }\n\n                if(args.length)\n                {      \n                    if(needTo)\n                    {\n                        values = this._parseDataArg(args.shift(), 'to', values);\n                    }\n\n                    if(args.length)\n                    {\n                        // if not yet passed, check for duration param after the style properties \n                        if(!('duration' in values) && (isString(args[0]) || isNumber(args[0])))\n                        {\n                            values.duration = args.shift();\n                        }\n\n                        if(args.length)\n                        {\n                            // timeline position, when needed, is expected here after duration\n                            if(needPos && (isString(args[0]) || isNumber(args[0])))\n                            {\n                                pos = args.shift();\n                            }\n\n                            if(args.length)\n                            {                            \n                                if(isString(args[0]) || isArray(args[0]))\n                                {\n                                    values.easing = args.shift();\n                                }\n                                else if(!isFunction(args[0]))\n                                {           \n                                    values = this._parseDataArg(args.shift(), 'then', values);\n                                }\n                            }\n                        }\n\n                        // complete callback \n                        if(args.length && isFunction(args[0]))\n                        {\n                            var evt = ['end', args.shift()];\n                            if(args.length)\n                            {\n                                evt.push(isArray(args[0])? args[0] : [args[0]]);\n                                if(args.length)\n                                {\n                                    evt.push(args.shift());\n                                }\n                            }\n                            values.events.end = evt;\n                        }\n                    }\n                }\n            }\n        }\n\n        this._applyArguments(values);\n        if(needPos)\n        {\n            return pos;\n        }\n        return this;        \n    };\n\n\n    /**\n     * Clear the internal _data cache \n     * \n     */\n    this._reset = function()\n    {\n        this._data = null;\n    };\n\n    \n    /**\n     * Perform internal tasks needed before starting the tween\n     * \n     * @returns {this}\n     */\n    this._prepare = function()\n    {\n        if(!this._ready)\n        {   \n            this._reset();\n\n            if(this._emulatedProgress)\n            {\n                // stop the progress ticker on both ends of the tween\n                this\n                    .setCoreHandler('end', '_progress', this._stopProgress, this, [])\n                    .setCoreHandler('reverse', '_progress', this._stopProgress, this, []);                \n            }\n\n            // fill data with all time values converted to the unit used by the current driver\n            this._data = {\n                delay: convertTime(this._delay, this._coreTimeUnit, this._driverTimeUnit),\n                loopsDelay: convertTime(this._loopsDelay, this._coreTimeUnit, this._driverTimeUnit),\n                duration: convertTime(this._duration, this._coreTimeUnit, this._driverTimeUnit),\n                speed: this._speed,\n                easing: this._easing\n            };        \n\n            this._data.realDuration = this._data.duration / this.getRealSpeed();\n\n            // flags needed for further actions\n            this._hasBegin = false;\n            this._hasEnd = false;\n            this._hasThen = false;\n            this._hasTween = false;\n            this._hasPre = false;\n            this._hasMultipleEasing = false;\n            \n            // init data structures for handling display and visibility special properties \n            this._hasStaticProps = false;\n            this._staticProps = [];\n            this._display = {pre: null, begin: null, end: null, then: null, mask: 0};\n            this._visibility = {pre: null, begin: null, end: null, then: null, mask: 0};\n\n            this._data.tween = this._prepareProperties(this._from, this._to, this._then);                        \n\n            this._ready = true;\n        }\n        return this;        \n    };    \n\n\n    /**\n     * Return the number of dom elements selected as target for this tween. If the specific library used does not support target objects\n     * with a length property, this method should be overriden in the driver class\n     * \n     * @returns {number}\n     */\n    this._getTargetLength = function()\n    {\n        return this._target.length;\n    };\n\n\n    /**\n     * Create a common data structure after processing data hold in from, to and then objects, if set\n     * \n     * @param {object|null} from\n     * @param {object|null} to\n     * @param {object|null} then\n     * @returns {object|array}\n     */\n    this._prepareProperties = function(from, to, then)\n    {        \n        var tween = {};\n        this._prepareSingle(tween, to, 'end');\n        this._prepareSingle(tween, from, 'begin');\n        this._prepareSingle(tween, then, 'then');\n        \n        // if the used animation library does not have native support for play / pause / reverse / resume, it creates a clone of tween structure \n        // for each single dom target involved\n        if(this._emulatedPlayhead)\n        {\n            var i, end, \n                sortedTween = {}, \n                tweens = [],\n                name,\n                transformOrder = [\n                    'x', 'translateX', 'y', 'translateY', 'z', 'translateZ', \n                    'rotateZ', 'rotate', 'rotation', 'rotationZ', 'rotateX', 'rotationX', 'rotateY', 'rotationY', \n                    'scale', 'scaleX', 'scaleY', 'scaleZ' \n                ]\n            ;\n            \n            for(i = 0, end = transformOrder.length; i < end; i++)\n            {\n                name = transformOrder[i];\n                if(name in tween)\n                {\n                    sortedTween[name] = tween[name];\n                    delete tween[name];\n                }\n            }\n            \n            tween = extendObject(sortedTween, tween);\n                                                            \n            for(i = 0, end = this._getTargetLength(); i < end; i++)\n            {\n                tweens[i] = cloneObject(tween, true);\n            }\n            return tweens;\n        }\n        return tween;                \n    };    \n\n\n    \n\n\n    /**\n     * Process one block of properties\n     * \n     * @param {object} tween\n     * @param {object} block - one of from, to, then\n     * @param {string} type - 'begin' | 'end' | 'then'\n     */\n    this._prepareSingle = function(tween, block, type)\n    {\n        if(block)\n        {\n            block = this._parsePropertiesNames(block);\n            var data;\n            // bit mask used for display and visibility properties\n            // 1 = then, 2 = 'end', 4 = 'begin'. In case of 'end', value is copied in then too, so 3 is used instead of 2\n            var maskValue = type == 'then'? 1 : (type == 'end'? 3 : 4);\n            // _hasBegin | _hasEnd | _hasThen\n            var hasField = '_has' + type.substr(0, 1).toUpperCase() + type.substr(1);\n            for(var name in block)\n            {\n                if(block.hasOwnProperty(name))\n                {\n                    var easing = null, value = block[name], found;\n\n                    // per-property easing \n                    if(isArray(value))\n                    {\n                        easing = this._allowMultipleEasing? value[1] : null;\n                        value = value[0];\n\n                        // per-property easing passed with then object is ignored\n                        this._hasMultipleEasing = (easing && type != 'then');\n                    }\n\n                    if(name == 'display' || name == 'visibility')\n                    {\n                        this['_' + name][type] = value;\n                        this._hasStaticProps = true;\n                        this['_' + name].mask |= maskValue;            \n                        // 'then' object is processed after 'end', so if there is a static property there too, it will overwrite correctly the one set by 'end' call\n                        if(type == 'end')\n                        {\n                            this['_' + name].then = value;                            \n                        }\n                        continue;\n                    }\n\n                    this[hasField] = true;\n                    if(type != 'then')\n                    {\n                        this._hasTween = true;\n                    }\n\n                    if(type == 'end' || !(name in tween))\n                    {\n                        found = false;\n                        data = {\n                            pre: null,\n                            begin: null, \n                            end: null, \n                            then: null,\n                            easing: null, \n                            isTransform: false\n                        };                        \n                    }\n                    else\n                    {\n                        found = true;\n                        data = tween[name];\n                    }\n\n                    data[type] = value;\n\n                    if(type != 'then')\n                    {\n                        if(!found)\n                        {\n                            data.easing = easing;\n                        }\n                    }                    \n\n                    if(!data.isTransform)\n                    {\n                        data.isTransform = isTransformProperty(name);\n                    }                        \n\n                    tween[name] = data;\n                }\n            }\n        }                \n    };\n\n\n    /**\n     * utility function for splitting tween style values when per-property easing is specified\n     * currently used only by GSAP driver, so for simplicity it assumes that this._emulatePlayhead is false and tween data is not cloned \n     * for each dom target\n     * \n     * @param {objet} tween\n     * @returns {array}\n     */\n    this._splitEasing = function(tween)\n    {\n        var map = {},\n            tweens = [],\n            name, easing, easingName, entry;\n\n        for(name in tween)\n        {\n            entry = tween[name];\n            easing = entry.easing? entry.easing : this._easing; \n            // easing could be a string or an array, so we normalize array values to a string in order to have a proper value for the easing map\n            easingName = (isString(easing))? easing : easing.join('_').replace(/\\./g, 'p');\n            if(!(easingName in map))\n            {\n                map[easingName] = tweens.length;\n                tweens.push({tween: {}, easing: easing});\n            }\n            tweens[map[easingName]].tween[name] = entry;            \n        }\n        return tweens;                        \n    };\n\n\n    /**\n     * Perform several actions on style properties passed\n     * \n     * @param {object} values\n     * @returns {object}\n     */\n    this._parsePropertiesNames = function(values)\n    {\n        var newValues = {}, newName, subValues;\n        for(var name in values)\n        {\n            if(values.hasOwnProperty(name))\n            {\n                // convert dashed names to camelCase version\n                newName = camelize(name);                                            \n                \n                // split compund properties like padding: 10px 20px to a list of single-valued properties\n                if(inArray(compoundNames, newName) !== -1)\n                {\n                    subValues = compoundMapping(newName, values[name]);\n                }\n                // split compound transform properties like translate: 10 20 to a list of single-valued transform properties\n                else if(this._allowTransform && inArray(compoundTransforms, newName) !== -1)\n                {\n                    subValues = transformMapping(newName, values[name]);\n                }\n                else\n                {\n                    subValues = {};\n                    subValues[newName] = values[name];\n                }\n                                    \n                for(name in subValues)\n                {\n                    // if found, replace the given name with the alias accepted by the specific animation library\n                    newName = name in this._propertyMap? this._propertyMap[name] : name;\n                    // if transformation are not supported (using jQuery as animation library, for example) any transform property is dropped\n                    if(this._allowTransform || !isTransformProperty(newName))\n                    {\n                        newValues[newName] = subValues[name];                    \n                    }\n                }\n            }\n        }\n        return newValues;\n    };\n\n\n    /**\n     * Transform the given easing value in the form accepted by the specific animation library. In most of the case, the driver has to override \n     * _getBezierEasing() method \n     * \n     * @param {string|array} value\n     * @returns {string|array|function}\n     */    \n    this._getRealEasing = function(value)\n    {\n        // check for shortcut set in Tweene.easings\n        if(isString(value) && value in easings)\n        {\n            value = easings[value];\n        }\n\n        // cubic bezier curve array\n        if(isArray(value) && value.length == 4)\n        {\n            value = this._getBezierEasing(value);\n        }\n\n        return value;\n    };\n\n\n    /**\n     * Duplicate style properties object and check for any options and event handlers passed together\n     * \n     * @param {object} data - only plain object accepted, else it throws an exception \n     * @param {string} name - 'from' | 'to' | 'then'\n     * @param {object} values - destination container\n     * @returns {object}\n     */\n    this._parseDataArg = function(data, name, values)\n    {        \n        if(!seemsPlainObject(data))\n        {\n            throw 'Expected plain object as argument';\n        }\n        data = cloneObject(data, true);    \n        var options = this._parseOptions(data, true);\n        var events = this._parseEvents(data, true);\n        if(keys(data).length)\n        {\n            values[name] = data;\n        }\n        values = extendObject(values, options);\n        values.events = extendObject(values.events, events);\n        return values;\n    };                   \n\n};","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods common to every timeline object, whatever is the driver used\n * @mixin\n *\n */\nvar TimelineCommon = function()\n{\n    this.type = 'timeline';\n\n    this._offset = 0;\n\n    this._children = [];\n\n    this._cursor = null;\n\n    this._labels = {};\n\n\n    /**\n     * Add tweens, timelines, callbacks and labels to current timeline object\n     * @link http://tweene.com/docs/#timelineAdd\n     * @link http://tweene.com/docs/#nestedTimelines\n     * @link http://tweene.com/docs/#directionalCallbacks\n     * @link http://tweene.com/docs/#labels\n     *\n     * @param {string|object|number} child - number is accepted only when adding directional callback\n     * @param {string|number} [startPosition]\n     * @returns {this}\n     */\n    this.add = function(child, startPosition)\n    {\n        // adding a label\n        if(isString(child))\n        {\n            // label needs to start with an alphabetic character and cannot contains arithmetic symbols specified in the regexp here\n            if(child.search(/^[a-z][^\\+\\-=]*$/) != -1)\n            {\n                child = new Label(child);\n                this._labels[child.id()] = child;\n            }\n            else\n            {\n                throw 'The label \"' + child +'\" contains invalid symbols';\n            }\n        }\n        else\n        {\n            // adding a callback or directional callback\n            if(isFunction(child) || (isNumber(child) && isFunction(startPosition)))\n            {\n                var dir = 0, i = 0;\n                // when a number is passed as first arg, it is a directional callback and we need to shift left the other params\n                if(isNumber(child))\n                {\n                    dir = child;\n                    child = startPosition;\n                    startPosition = arguments[2] || null;\n                    i = 1;\n                }\n                i = i + 2;\n                // params expected after the callback\n                var params = arguments.length > i? (isArray(arguments[i])? arguments[i] : [arguments[i]]) : [];\n                i ++;\n                // callback scope object expected after callback params\n                var scope = arguments.length > i? arguments[i] : null;\n                child = new Callback(child, scope, params, dir, false);\n            }\n\n            child.parent(this);\n        }\n\n        if(startPosition === void 0)\n        {\n            startPosition = null;\n        }\n\n        this._children.push({id: child.id(), child: child, start: startPosition});\n        this.invalidate();\n        return this;\n    };\n\n\n    /**\n     * Add pause, with an optional callback\n     * @link http://tweene.com/docs/#addPause\n     *\n     * @param {string|number} [startPosition]\n     * @param {string|number} [callbackDirection]\n     * @param {function} [callback] - callback\n     * @param {array} [params] - callback params\n     * @param {object} [scope] - callback scope\n     * @returns {this}\n     */\n    this.addPause = function()\n    {\n        var args = toArray(arguments),\n            startPosition = null,\n            dir = 0,\n            callback = null,\n            params = [],\n            scope = null,\n            arg,\n            child;\n\n        if(args.length)\n        {\n            arg = args.shift();\n            if(isFunction(arg))\n            {\n                callback = arg;\n            }\n            else\n            {\n                startPosition = arg;\n            }\n\n            if(args.length)\n            {\n                arg = args.shift();\n                if(!callback)\n                {\n                    if(isNumber(arg))\n                    {\n                        dir = arg;\n                        if(args.length)\n                        {\n                            callback = args.shift();\n                        }\n                    }\n                    else\n                    {\n                        callback = arg;\n                    }\n                }\n\n                if(callback && args.length)\n                {\n                    params = args.shift();\n                    if(!isArray(params))\n                    {\n                        params = [params];\n                    }\n\n                    if(args.length)\n                    {\n                        scope = args.shift();\n                    }\n                }\n            }\n        }\n\n        child = new Callback(callback, scope, params, dir, true);\n        child.parent(this);\n        this._children.push({id: child.id(), child: child, start: startPosition});\n        this.invalidate();\n        return this;\n    };\n\n\n\n    /**\n     * Create a tween and execute a previously registered macro on it\n     * If the timeline has not a target specified, it expects a target as first param.\n     * It expects a position as second (or first) param, all other params are passed to the tween exec() method\n     *\n     * @returns {this}\n     */\n    this.exec = function()\n    {\n        var args = toArray(arguments);\n        if(args.length)\n        {\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            var pos = args.length > 1?  args.splice(1, 1)[0] : null;\n            this.add(tween, pos);\n            tween.exec.apply(tween, args);\n        }\n        return this;\n    };\n\n    /**\n     * Schedule a tween with duration = 0\n     * @link http://tweene.com/docs/#timelineSet\n     *\n     * @returns {this}\n     */\n    this.set = function()\n    {\n        var args = toArray(arguments);\n        if(args.length)\n        {\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            if(args.length)\n            {\n                var values = args.shift();\n                var pos = args.length? args.shift() : null;\n                tween._to = values;\n                tween.duration(0);\n                this.add(tween, pos);\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().to())\n     * @link http://tweene.com/docs/#timelineTo\n     *\n     * @returns {this}\n     */\n    this.to = function()\n    {\n        return this._tweenMethod(arguments, false, true);\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().fromTo())\n     * @link http://tweene.com/docs/#timelineFromTo\n     *\n     * @returns {this}\n     */\n    this.fromTo = function()\n    {\n        return this._tweenMethod(arguments, true, true);\n    };\n\n\n    /**\n     * Shortcut for .add(Tweene.get().from())\n     * @link http://tweene.com/docs/#timelineFrom\n     *\n     * @returns {this}\n     */\n    this.from = function()\n    {\n        return this._tweenMethod(arguments, true, false);\n    };\n\n\n    /**\n     * used internally for setting child timeline time position inside the parent\n     *\n     * @param {number} value\n     * @returns {this}\n     */\n    this.offset = function(value)\n    {\n        this._offset = value;\n        return this;\n    };\n\n\n    /**\n     * Timeline need to process its children just before starting or when you ask for duration. See implementation in TimelinePro or\n     * in specific drivers\n     *\n     * @returns {this}\n     */\n    this.prepare = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        this._reset();\n        this._mergeChildren();\n        this.ready = true;\n        return this;\n    };\n\n\n    /**\n     * Perform all the common actions needed by .to(), .from() and .fromTo()\n     *\n     * @param {arguments} args\n     * @param {boolean} from\n     * @param {boolean} to\n     * @returns {this}\n     */\n    this._tweenMethod = function(args, from, to)\n    {\n        args = toArray(args);\n        if(args.length)\n        {\n            // use first argument as target if the timeline does not have a global target set\n            var target = this._target? this._target : args.shift();\n            var tween = Tw.get(target, this.driverName);\n            var pos = tween.parseArguments(args, from, to, true);\n            this.add(tween, pos);\n        }\n        return this;\n    };\n\n\n    /**\n     * Process all the children added evaluating their actual time position inside the timeline\n     *\n     * @returns {this}\n     */\n    this._mergeChildren = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        // cursor will contains the end of the last processed child, while duration holds the overall end of the timeline\n        this._cursor = this._duration = 0;\n\n        var child, begin, end, start, childDelay, tweenable;\n        for(var i = 0, len = this._children.length; i < len; i++)\n        {\n            child = this._children[i].child;\n            start = this._children[i].start;\n\n            tweenable = child.type == 'timeline' || child.type == 'tween';\n\n            if(tweenable)\n            {\n                // if the child has a delay, remove it from the child and use it as a start offset inside the timeline\n                childDelay = this._parseTime(child.delay());\n                if(childDelay)\n                {\n                    this._cursor += childDelay;\n                    this._duration += childDelay;\n                    child.delay(0);\n                }\n            }\n\n            // evaluate actual start position\n            begin = this._getStartPosition(this._duration, this._cursor, start);\n\n            if(child.type == 'label')\n            {\n                child.position(begin);\n                this._mergeLabel(child, begin);\n                continue;\n            }\n\n            if(tweenable)\n            {\n                if(child.type == 'timeline')\n                {\n                    child.offset(this._offset + begin);\n                }\n                // prepare() returns totalDuration\n                end = begin + child.prepare();\n                this._mergeTweenable(child, begin, end);\n            }\n            else\n            {\n                // callbacks have duration = 0\n                end = begin;\n                this._mergeCallback(child, begin, end);\n            }\n\n            // an infinite loop in a child tween or timeline results in its duration = Infinity\n            if(end != Infinity)\n            {\n                this._cursor = end;\n                if(this._cursor > this._duration)\n                {\n                    this._duration = this._cursor;\n                }\n            }\n            else\n            {\n                this._cursor = this._duration = Infinity;\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Evaluate actual time position of a child inside a timeline\n     *\n     * @param {number} currentDuration\n     * @param {number} currentCursor - end of the previously processed child\n     * @param {string|number} startPosition\n     *\n     * @returns {number}\n     */\n    this._getStartPosition = function(currentDuration, currentCursor, startPosition)\n    {\n        // by default, add to the end of the timeline, obtaining a queue of not-overlapping tweens\n        if(startPosition === null)\n        {\n            return currentDuration;\n        }\n        var start = currentDuration, pos, sign = 0, toCursor = false;\n        if(isString(startPosition))\n        {\n            // parts:\n            //  1 - label\n            //  2 - relative operator, +=, ++=, -=, --=\n            //  3 - time value, number or string with 's' or 'ms' suffix\n            var parts = startPosition.match(/^([a-z][^\\+\\-=]*)?(?:(\\+{1,2}|\\-{1,2})=)?([^\\+\\-=]+)?$/i);\n            if(parts === null)\n            {\n                return currentDuration;\n            }\n\n            pos = parts[3] !== void 0? this._parseTime(parts[3]) : 0;\n\n            if(parts[2] !== void 0)\n            {\n                toCursor = parts[2].length == 2;\n                sign = parts[2].substr(0, 1) == '-'? -1 : 1;\n            }\n\n            if(parts[1] !== void 0 && parts[1] in this._labels)\n            {\n                start = this._labels[parts[1]].position();\n                if(!sign)\n                {\n                    pos = 0;\n                    sign = 1;\n                }\n            }\n            else\n            {\n                if(sign)\n                {\n                    start = toCursor? currentCursor: currentDuration;\n                }\n                else\n                {\n                    start = 0;\n                    sign = 1;\n                }\n            }\n        }\n        else\n        {\n            start = 0;\n            sign = 1;\n            pos = this._parseTime(startPosition);\n        }\n\n        if(start == Infinity)\n        {\n            return Infinity;\n        }\n\n        // cannot add child in negative positions, fallback to 0\n        return Math.max(0, start + (pos * sign));\n    };\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Ticker object used to emulate delay, progress callbacks, async calls.\n * It uses RequestAnimationFrame when available, with fallback to setTimeout.\n * We instantiate a single Ticker in Tweene.ticker\n * @class\n * \n */      \nvar Ticker = function()\n{\n    var _lastTime = 0;    \n    var _callbacks = [];\n    \n    this.now = Date.now || function() \n    {\n        return new Date().getTime();\n    };\n    \n    var _now = this.now;\n    \n    /*\n     *  Polyfill taken here: https://gist.github.com/paulirish/1579671\n     *  \n     * requestAnimationFrame polyfill by Erik Mller. fixes from Paul Irish and Tino Zijdel\n     * MIT license    \n     *  \n     */\n    var _requestAnimationFrame = \n        window.requestAnimationFrame || \n        window.webkitRequestAnimationFrame || \n        window.mozRequestAnimationFrame || \n        window.msRequestAnimationFrame ||\n        window.oRequestAnimationFrame || \n        \n        function(callback) \n        {\n            var currTime = _now();\n            var timeToCall = Math.max(0, 16 - (currTime - _lastTime));\n            var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);\n            _lastTime = currTime + timeToCall;\n            return id;\n        };\n        \n\n\n    var _tick = function()\n    {\n        var now = _now();\n        var i = 0;\n        while(i < _callbacks.length)\n        {\n            var entry = _callbacks[i];\n            var call = (!entry.time || now - entry.now - entry.time >= 0);\n            if(call && entry.time)\n            {\n                // remove expired callback\n                _callbacks.splice(i, 1);\n            }\n            else\n            {\n                i++;\n            }\n            if(call)\n            {\n                entry.callback.apply(entry.scope, entry.params);\n            }\n        }\n        // ticker is turned off when the callbacks list is empty\n        if(_callbacks.length)\n        {\n            _requestAnimationFrame(_tick);\n        }\n    };\n\n\n    /**\n     * Register a callback \n     * \n     * @param {number} time - Timeout in ms. When = 0, the function will be called on each tick and need to be unregistered manually\n     * @param {string} id - unique identifier of the registered callback\n     * @param {function} callback\n     * @param {object} [scope] scope used as 'this' inside the callback\n     * @param {array} [params] params to be passed to the callback on execution\n     * @returns {this}\n     */\n    this.addCallback = function(time, id, callback, scope, params)\n    {\n        this.removeCallback(id);        \n        _callbacks.push({now: _now(), time: time, id: id, callback: callback, scope: scope || this, params: params || []});\n        \n        // turn on ticker if it is the first callback in queue \n        if(_callbacks.length == 1)\n        {\n            _requestAnimationFrame(_tick);\n        }\n        return this;\n    };        \n\n\n    /**\n     * Unregister a callback. Callbacks registered with a positive timeout, commonly do not need to be unregistered manually, \n     * the ticker unregister them after automatically after their execution.\n     * \n     * @param {string} id - unique identifier of the registered callback\n     * @returns {this}\n     */\n    this.removeCallback = function(id)\n    {\n        for(var i = 0, end = _callbacks.length; i < end; i++)\n        {\n            if(_callbacks[i].id == id)\n            {\n                _callbacks.splice(i, 1);            \n                break;\n            }\n        }\n        return this;\n    };        \n    \n};\n  \n  \nTw.ticker = new Ticker();  \n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods common to tween and timeline, for animation library that does not have native support\n * for playhead control (play / pause / reverse and so on)\n * @mixin\n *\n */\nvar ControlsPro = function()\n{\n    this._time = null;\n\n    this._startTime = 0;\n\n    this._pauseTime = 0;\n\n    this._position = 0;\n\n    this._paused = true;\n\n    this._running = false;\n\n    this._delayDummy = null;\n\n    this._emulatedProgress = false;\n\n    this._emulatedBegin = false;\n\n    this._playAllowed = true;\n\n    this._reverseAllowed = false;\n\n\n    /**\n     * play() and reverse() acts on both global and local direction (_fwd and _localFwd properties), while the change\n     * in direction performed during a yoyo loop changes only local direction\n     *\n     * @param {boolean} value\n     * @returns {this}\n     */\n    this.setDir = function(value)\n    {\n        this._fwd = value;\n        this.setLocalDir(value);\n        return this;\n\n    };\n\n    /**\n     * Change the actual local direction of the animation\n     *\n     * @param {boolean} value\n     * @returns {this}\n     */\n    this.setLocalDir = function(value)\n    {\n        this._localFwd = value;\n        // change direction of the delay too\n        if(this._delayDummy)\n        {\n            this._delayDummy.setDir(value);\n        }\n        // when changing direction of a timeline, the change cascades to children\n        if(this.type != 'tween')\n        {\n            this._propagateToAll('setDir', value);\n        }\n        return this;\n    };\n\n\n    /**\n     * Swap the global direction, from forward to backward or vice versa\n     *\n     * @returns {this}\n     */\n    this.swapDir = function()\n    {\n        this._fwd = !this._fwd;\n        this.swapLocalDir();\n        return this;\n    };\n\n\n    /**\n     * Swap the actual local direction, from forward to backward or vice versa\n     *\n     * @returns {this}\n     */\n    this.swapLocalDir = function()\n    {\n        this._localFwd = !this._localFwd;\n        if(this._delayDummy)\n        {\n            this._delayDummy.swapDir();\n        }\n        if(this.type != 'tween')\n        {\n            this._propagateToAll('swapDir');\n        }\n        return this;\n    };\n\n\n    /**\n     * Override Common.play()\n     *\n     */\n    this.play = function()\n    {\n        // play not allowed when the current playhead position is at the end of the duration\n        if(this._playAllowed)\n        {\n            this._reverseAllowed = true;\n            if(!this._fwd)\n            {\n                this.pause();\n                this.swapDir();\n            }\n            this.resume();\n        }\n        return this;\n    };\n\n\n    /**\n     * Override Common.reverse()\n     *\n     */\n    this.reverse = function()\n    {\n        // reverse is not allowed when the playhead position is equal to 0 (begin of the current animation)\n        if(this._reverseAllowed)\n        {\n            this._playAllowed = true;\n            if(this._fwd)\n            {\n                this.pause();\n                this.swapDir();\n            }\n            this.resume();\n        }\n        return this;\n    };\n\n\n    /**\n     * Override Common.pause()\n     *\n     */\n    this.pause = function()\n    {\n//        console.log(this._id, 'pause');\n        // if not ready, it means that is not yet started, so no need to perform a pause\n        if(this._ready)\n        {\n            // stop progress ticker, if present\n            this._stopProgress();\n\n            // propagate pause to delay, if present\n            if(this._delayDummy)\n            {\n                this._delayDummy.pause();\n                this._paused = true;\n                return this;\n            }\n\n            if(!this._paused)\n            {\n//                console.log(this._id, 'pausing');\n                this._paused = true;\n\n                this._pauseTime = Tw.ticker.now();\n                // evaluate pause position on playhead\n                this._position += (this._pauseTime - this._startTime) * this.getRealSpeed() * (this._localFwd? 1 : -1);\n\n                this._pauseTween();\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Override Common.resume()\n     *\n     */\n    this.resume = function()\n    {\n//        if(this._parent && this._parent.paused())\n//        {\n//            return this;\n//        }\n//        console.log(this._id, 'resume', (this._parent && this._parent.paused()? 'parent paused': 'parent running'));\n        if(this._paused && (this._fwd && this._playAllowed || !this._fwd && this._reverseAllowed))\n        {\n            this._paused = false;\n            this.prepare();\n\n            // propagate resume to delay, if present\n            if(this._delayDummy)\n            {\n                this._delayDummy.resume();\n                return this;\n            }\n\n            // evaluate remaining duration, accordingly with current position, direction and speed\n            if(this.type != 'timeline')\n            {\n                var duration = this._localFwd? this._duration - this._position : this._position;\n                this._data.duration = convertTime(duration, this._coreTimeUnit, this._driverTimeUnit);\n                this._data.realDuration = this._data.duration / this.getRealSpeed();\n            }\n            this._startTime = Tw.ticker.now();\n\n            if(this._duration)\n            {\n                this._playAllowed = true;\n                this._reverseAllowed = true;\n            }\n\n            // always true after the very first execution of resume()\n            if(this._running)\n            {\n                if(this._duration)\n                {\n                    // resume progress ticker, if needed\n                    this._startProgress();\n                }\n\n                // when the animation library does not have native support for begin callback\n                if(this._emulatedBegin && this._hasHandlers('_begin'))\n                {\n                    this._runHandlers('_begin');\n                }\n\n                // at both ends of the tween (begin in forward dir, end in backward dir) perform preTween actions\n                if(this.type != 'timeline' && ((this._position === 0 && this._localFwd) || (this._position == this._duration && !this._localFwd)))\n                {\n                    this._preTween(this._localFwd);\n                }\n                this._resumeTween();\n            }\n            else\n            {\n                this._loopsCount = 0;\n                // we need pausable and reversable delay, so we ignore any native support for delay and always emulate it\n                if(this._delay)\n                {\n                    this._emulateDelay(this._delay, this._run);\n                }\n                else\n                {\n                    this._run();\n                }\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Override Common.restart()\n     *\n     */\n    this.restart = function()\n    {\n        if(this._keyCurrentIndex !== null)\n        {\n            this._keyCurrentIndex = null;\n        }\n\n        this.pause();\n        this.setDir(true);\n        this.back();\n        this.resume();\n        return this;\n    };\n\n\n    /**\n     * Override Common.back()\n     *\n     */\n    this.back = function()\n    {\n        // reset loop counter accordingly with direction\n        if(this._loops)\n        {\n            if(this._fwd)\n            {\n                this._loopsCount = 0;\n            }\n            else\n            {\n                if(this._loops != -1)\n                {\n                    this._loopsCount = this._loops + 1;\n                }\n            }\n        }\n\n        if(this._running)\n        {\n            this._back();\n        }\n        this._playAllowed = this._fwd;\n        this._reverseAllowed = !this._playAllowed;\n        return this;\n    };\n\n\n    /**\n     * Override Common.speed()\n     *\n     */\n    this.speed = function(value)\n    {\n        if(value === void 0)\n        {\n            return this._speed;\n        }\n\n        if(!this._running)\n        {\n            this.invalidate();\n        }\n        value = parseSpeed(value);\n\n        if(value != this._speed)\n        {\n            // changing speed in running animations is performed pausing and immediately resuming with the new speed\n            var notPaused = !this._paused;\n            if(notPaused)\n            {\n                this.pause();\n            }\n\n            this._speed = value;\n\n            if(notPaused)\n            {\n                this.resume();\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Calculate current time position, needed only by info methods like time() and progress()\n     *\n     * @returns {number}\n     */\n    this._getPosition = function()\n    {\n        if(this._time !== null)\n        {\n            return this._time;\n        }\n        if(this._paused)\n        {\n            return this._position;\n        }\n        var now = Tw.ticker.now();\n        return Math.max(0, this._position + (now - this._startTime) * this.getRealSpeed() * (this._localFwd? 1 : -1));\n    };\n\n\n    /**\n     * Calculate the current percent progress, as a value between 0 and 1\n     *\n     * @returns {number}\n     */\n    this._getProgress = function()\n    {\n        return Math.max(0, Math.min(1, this._getPosition() / this._duration));\n    };\n\n\n    /**\n     * Get the current running status\n     *\n     * @returns {boolean}\n     */\n    this._getPaused = function()\n    {\n        return this._paused;\n    };\n\n\n    /**\n     * Reset the internal playhead position on both ends of animation\n     *\n     */\n    this._resetPosition = function()\n    {\n        this._paused = true;\n        this._position = this._localFwd? this._duration : 0;\n        this._startTime = this._pauseTime = 0;\n    };\n\n\n    /**\n     * Used to emulate a progress / update callback when the driver lacks native support for it\n     *\n     */\n    this._startProgress = function()\n    {\n        if(this._emulatedProgress && this._hasHandlers('progress'))\n        {\n            // passing 0 as first param, it will fire until it is manually removed\n            Tw.ticker.addCallback(0, this._id + '_progress', this._runHandlers, this, ['progress']);\n        }\n    };\n\n\n    /**\n     * Used to emulate a progress / update callback when the driver lacks native support for it\n     *\n     */\n    this._stopProgress = function()\n    {\n        if(this._emulatedProgress && this._hasHandlers('progress'))\n        {\n            Tw.ticker.removeCallback(this._id + '_progress');\n        }\n    };\n\n\n    /**\n     * Internal method used to restart the animation in both directions.\n     *\n     */\n    this._restart = function()\n    {\n        this._delayDummy = null;\n        this.pause();\n        this._back();\n        this.resume();\n    };\n\n\n    /**\n     * Used in loop or manual restart, it reset data and animation to the begin (or end) state accordingly to direction\n     *\n     * @returns {this}\n     */\n    this._back = function()\n    {\n        this._position = this._localFwd? 0 : this._duration;\n        if(this._running)\n        {\n            this._delayDummy = null;\n            var dir = this._localFwd? (this._hasPre && this._offset !== 0? 'pre' : 'begin') : 'end';\n            this._backTween(dir);\n        }\n        return this;\n    };\n\n\n    /**\n     * Update loop counter when running in backward direction and restart\n     *\n     */\n    this._loopRev = function()\n    {\n        this._loopsCount --;\n        this._restart();\n    };\n\n\n    /**\n     * Update loop counter when running in forward direction and restart\n     *\n     */\n    this._loopFwd = function()\n    {\n        this._runHandlers('loop');\n        if(this._yoyo)\n        {\n            this.swapLocalDir();\n        }\n        this._restart();\n    };\n\n\n    /**\n     * loop controller, performed on both ends of animation, accordingly with current direction and yoyo property\n     *\n     */\n    this._loopCheck = function()\n    {\n        this._delayDummy = null;\n        if(this._fwd)\n        {\n            this._loopsCount++;\n        }\n        else\n        {\n            if(this._yoyo)\n            {\n                this.swapLocalDir();\n            }\n            this._runHandlers('loop');\n        }\n\n        if(this._loopsDelay)\n        {\n            if(!this._fwd && !this._yoyo)\n            {\n                // delay is executed on final position in order to have a simmetric animation between both directions\n                this._back();\n            }\n            this._emulateDelay(this._loopsDelay, this._loopFwd, this._loopRev);\n        }\n        else\n        {\n            if(this._fwd)\n            {\n                this._loopFwd();\n            }\n            else\n            {\n                this._loopRev();\n            }\n        }\n    };\n\n\n\n    /**\n     * Emulate delay and loopsDelay using a special Dummy Tween\n     *\n     * @param {number} delay\n     * @param {function} callback\n     * @param {function} [reverseCallback] - used only in loopsDelay\n     */\n    this._emulateDelay = function(delay, callback, reverseCallback)\n    {\n        var dummy = this._delayDummy = this._getDummy()\n            .duration(delay)\n            .setCoreHandler('end', name, callback, this);\n\n        // only loopsDelay has reverseCallback set\n        if(reverseCallback)\n        {\n            dummy.position(this._fwd? 0 : delay);\n            // progress callback is not paused during loops delay\n            if(this._emulatedPlayhead && this._hasHandlers('progress'))\n            {\n                dummy.setCoreHandler('progress', '_progress', this._runHandlers, this, ['progress']);\n            }\n            dummy.setCoreHandler('reverse', name, reverseCallback, this);\n        }\n\n        dummy[this._fwd? 'play' : 'reverse']();\n    };\n\n\n    /**\n     * Internal event handler needed to perform actions at the begin of the animation\n     */\n    this._onTweenBegin = function()\n    {\n        if(this._position === 0 && this._localFwd)\n        {\n            // begin event is not raised on loop iterations\n            if(this._loopsCount === 0)\n            {\n                this._runHandlers('begin');\n            }\n        }\n    };\n\n\n    /**\n     * Internal event handler needed to perform actions at the end of the animation\n     */\n    this._onTweenEnd = function()\n    {\n        this._resetPosition();\n\n        if(this._localFwd)\n        {\n            if(this._loopsCount == this._loops)\n            {\n                if(this.type != 'timeline')\n                {\n                    this._postTween('end');\n                }\n                this._playAllowed = false;\n                this._time = this._duration;\n                this._runHandlers('end');\n                this._time = null;\n            }\n            else if(this._loops !== 0)\n            {\n                this._loopCheck();\n            }\n        }\n        else\n        {\n            if(this._loopsCount === 0)\n            {\n                if(this.type != 'timeline')\n                {\n                    this._postTween('begin');\n                }\n                this._reverseAllowed = false;\n                this._time = 0;\n                this._runHandlers('reverse');\n                this._time = null;\n            }\n            else if(this._loops !== 0)\n            {\n                this._loopCheck();\n            }\n        }\n    };\n\n\n    /**\n     * Create a Dummy object\n     * @see TweeneDummy\n     *\n     * @returns {object}\n     */\n    this._getDummy = function()\n    {\n        // Dummy don't need any target\n        return Tw.get(null, 'Dummy');\n    };\n\n\n    // register some internal handlers\n    this.setCoreHandler('_begin', '_begin', this._onTweenBegin, this);\n    this.setCoreHandler('_end', '_end', this._onTweenEnd, this);\n\n};\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n\n// used as cache for vendor-prefixed names\nvar propertyNames = {};\n\n/**\n * Get style real name and value, checking for browser prefixes if needed\n * \n * @param {object} style\n * @param {string} name\n * @returns {array} - return [realName, value]\n */\nfunction getProperty(style, name)\n{\n    if(style[name] !== void 0)\n    {\n        return [name, style[name]];\n    }\n    if(name in propertyNames)\n    {\n        return [propertyNames[name], style[propertyNames[name]]];\n    }\n    name = name.substr(0, 1).toUpperCase() + name.substr(1);\n    var prefixes = ['webkit', 'moz', 'ms', 'o'], fullName;\n    for(var i = 0, end = prefixes.length; i < end; i++)\n    {\n        fullName = prefixes[i] + name;\n        if(style[fullName] !== void 0)\n        {\n            propertyNames[name] = fullName;\n            return [fullName, style[fullName]];\n        }\n    }\n    return [name, void 0];        \n}\n\n\n/**\n * Reverse a cubic bezier, needed for playing tweens backwards\n * \n * @param {array} value - 4-length cubic bezier array\n * @returns {array}\n */\nfunction reverseBezier(value)\n{\n    return [\n        1 - value[2],\n        1 - value[3],\n        1 - value[0],\n        1 - value[1]\n    ];\n}\n\n\n// needed by next func\nvar bezierEasingCache = {};\n\n/**\n * Widely based on the great work by Vincent Tan\n * http://polymathprogrammer.com/2007/06/27/reverse-engineering-bezier-curves/\n * \n * given a bezier curve and current time progress, it returns a new cubic bezier array equal to the remaining part of the curve\n * \n * @param {Array} oldBezier - 4-length cubic bezier array\n * @param {Number} time -  current progress value, between 0 and 1 \n * @returns {Array}\n */\nfunction getNewBezier(oldBezier, time)         \n{                \n    if(time === 0 || time === 1)\n    {\n        return oldBezier;\n    }\n\n    var cacheName = oldBezier.join('_').replace(/\\./g, 'p') + '_' + time.toFixed(3);\n    if(cacheName in bezierEasingCache)\n    {\n        return bezierEasingCache[cacheName];\n    }        \n\n    var oldBezierFunc = bezier.apply(null, oldBezier);\n    var xInterval = 1 - time;\n    var startY = oldBezierFunc(time);\n    var sign = startY > 1? - 1 : 1;\n    var yInterval = (1 - startY) * sign;\n\n    var u = 0.33, v = 0.67;\n    var uu = u * xInterval + time;\n    var vv = v * xInterval + time;\n\n    var \n        p0x = 0, p0y = 0,\n        p1x = u, p1y = (oldBezierFunc(uu) - startY) * sign / yInterval, \n        p2x = v, p2y = (oldBezierFunc(vv) - startY) * sign / yInterval, \n        p3x = 1, p3y = 1,\n        compU = 1 - u, compV = 1 -v, \n        u2 = u * u, u3 = u * u * u, v2 = v * v, v3 = v * v * v,\n\n        a = 3 * compU * compU * u, b = 3 * compU * u2, \n        c = 3 * compV * compV * v, d = 3 * compV * v2;       \n\n    var det = a*d - b*c;\n\n    /* it would not be needed, it's just to honor Murphy's Law */\n    if(det === 0) \n    {\n        console.log('New Bezier FAIL: Det == 0'); \n        return oldBezier;\n    }\n\n    var compU3 = compU * compU * compU, compV3 = compV * compV * compV;\n\n    var \n        q1x = p1x - (compU3 * p0x + u3 * p3x),\n        q1y = p1y - (compU3 * p0y + u3 * p3y),\t\n        q2x = p2x - (compV3 * p0x + v3 * p3x),\n        q2y = p2y - (compV3 * p0y + v3 * p3y);\n\n    var res = [\n        (d * q1x - b * q2x) / det,\n        (d * q1y - b * q2y) / det,\n\n        ((-c) * q1x + a * q2x) / det,\n        ((-c) * q1y + a * q2y) / det\n    ];\n\n    bezierEasingCache[cacheName] = res;\n    return res;\n}\n\n\n\n\n/**\n * Vars and methods used in tween object, for animation library that does not have native support \n * for playhead control (play / pause / reverse and so on) \n * @mixin\n * \n */\nvar TweenPro = function()\n{        \n    this._beginReady = this._endReady = this._thenReady = false;\n    \n    \n    \n    /**\n     * Called on first tween start\n     * \n     * @returns {TweenPro}\n     */\n    this._run = function()\n    {\n        if(this._duration)\n        {\n            this._startProgress();\n        }\n        // get current display and/or visibility values before starting, if needed\n        if(this._hasStaticProps)\n        {\n            this._fetchStaticProps();\n            this._setStaticProps('tween');                                        \n        }\n\n        this._running = true;\n        this._delayDummy = null;\n        \n        if(this._emulatedBegin && this._hasHandlers('_begin'))\n        {\n            this._runHandlers('_begin');\n        }\n        \n        // if from() or fromTo() tween, need to jump to begin position before starting the animation\n        if(this._emulatedFrom && this._from)\n        {\n            this._setTween('begin');\n        }\n        \n        this._startTime = Tw.ticker.now();             \n        this._playTween();\n\n        return this;            \n    };                                 \n\n\n    /**\n     * Used to restore begin or end style values accordingly to current direction\n     * \n     * @param {string} field\n     */\n    this._backTween = function(field)\n    {\n        this._resetTween(field);\n    };\n\n\n    /**\n     * Set style values accordinglty to the param, and perform postTween actions\n     * \n     * @param {string} field\n     */\n    this._resetTween = function(field)\n    {\n        this._setTween(field);\n        this._postTween(field);            \n    };\n\n\n    /**\n     * Perform actions before starting the tween. Apply to both directions\n     * \n     * @param {boolean} direction - true = forward, false = backward\n     */\n    this._preTween = function(direction)\n    {\n        var field = direction? 'begin' : 'end';\n        if(this._hasStaticProps && this._duration)\n        {\n            this._setStaticProps(field, 'tween');                            \n        }\n        this._setTween(field);\n    };\n    \n\n    /**\n     * Perform actions after ending the tween. Apply to both directions\n     * \n     * @param {string} field\n     */\n    this._postTween = function(field)\n    {\n        if(field == 'end')                \n        {\n            if(this._hasThen)\n            {\n                this._setTween('then');\n            }\n            if(this._hasStaticProps)\n            {\n                this._setStaticProps(field, 'then');\n            }\n        }\n        else\n        {\n            // if the tween is reversed, restore previous style values\n            // this is needed in timelines, when a reversed tween is preceded by others that refer common targets, with a time gap between them\n            // otherwise, during the time gap in reverse direction the targets will have wrong style values\n            if(this._hasPre)// && this._offset !== 0)\n            {\n                this._setTween('pre');\n            }\n            this._setStaticProps(field);\n        }\n\n    };\n\n\n    /**\n     * Get a simple name: value map of style property, ready to be passed to the chosen animation library.\n     * If supported, set also the per-property easing specified by the user\n     * \n     * @param {object} tween - tween data structure\n     * @param {string} field - 'begin' | 'end' | 'pre' | 'then'\n     * @param {boolean} isSet - true when the values are needed for changing the style instantly. Easing info are omitted in this case\n     * @returns {object}\n     */\n    this._getTweenValues = function(tween, field, isSet)\n    {\n        var values = {}, entry, value, name, easing, i = 0;\n        for(name in tween)\n        {\n            entry = tween[name];\n            value = null;\n            easing = entry.easing;\n\n            if(entry[field] !== null)\n            {\n                i++;\n                // cast pure numeric string to number. This avoid bugs in Transit and other libraries that potentially does not support numeric \n                // values passed as string\n                value = isNumeric(entry[field])? Number(entry[field]) : entry[field];\n                value = isSet || !this._allowMultipleEasing || !easing? value : [value, this._getRealEasing(easing)];\n                values[name] = value;\n            }            \n        }\n\n        // instead of handling different errors from any library involved, if there are no values to set, we force a fake tween\n        if(!i)\n        {\n            values.opacity = '+=0';\n        }\n\n        return values;\n    };\n\n\n    /**\n     * Fetch a style value for a dom element\n     * \n     * @param {object} item - dom element\n     * @param {string} name - property name\n     * @param {boolean} useStyle - if true, use element.style instead of computedStyle value\n     * @returns {string|number}\n     */\n    this._getCurrentValue = function(item, name, useStyle)\n    {\n        var style = useStyle? item.style : window.getComputedStyle(item);\n        return style[name];        \n    };\n\n\n    /**\n     * Fetch current values for display and / or visibility properties\n     * \n     */\n    this._fetchStaticProps = function()\n    {             \n        this._staticProps = [];\n        \n        var item, i, end, names, name, value, fieldName, field, hidden, tweenValue, values;\n        for(i = 0, end = this._getTargetLength(); i < end; i++)\n        {\n            item = this._target.get(i);\n            names = {display: false, visibility: false};\n            \n            this._staticProps[i] = {\n                begin: {},\n                end: {},\n                then: {},\n                tween: {}\n            };\n            \n            for(name in names)\n            {\n                fieldName = '_' + name;\n                field = cloneObject(this[fieldName]);\n                if(field.mask > 0)\n                {\n                    if(field.mask < 7)\n                    {\n                        value = this._getCurrentValue(item, name, false);\n                        if(field.begin === null)\n                        {\n                            field.begin = value;\n                        }\n\n                        if(field.end === null)\n                        {\n                            field.end = value;\n                            if(field.then === null)\n                            {\n                                field.then = value;\n                            }\n                        }                                                                                \n                    }\n\n                    values = this._staticProps[i];\n                    \n                    values.begin[name] = field.begin;\n                    values.end[name] = field.end;\n                    values.then[name] = field.then;\n                    // values that show the element need to be set before the tween\n                    hidden = (name == 'display')? 'none' : 'hidden';\n                    tweenValue = field.begin != hidden? field.begin : (field.end != hidden? field.end : false);\n                    if(tweenValue !== false)\n                    {\n                        values.tween[name] = tweenValue;\n                    }                    \n                }\n            }\n        }\n    };\n    \n    \n    /**\n     * Set display and visibility properties, that are handled separately\n     * @link http://tweene.com/docs/#displayVisibility\n     * \n     * @param {string} first\n     * @param {string} [second] two set of values could be applied toghether in some cases, for example end + then or begin + tween\n     */\n    this._setStaticProps = function(first, second)\n    {\n        if(this._staticProps.length)\n        {\n            var i, end, values;\n            for(i = 0, end = this._getTargetLength(); i < end; i++)\n            {                \n                values = this._staticProps[i][first];\n                if(second)\n                {\n                    values = extendObject(values, this._staticProps[i][second]);\n                }\n                if(!isEmpty(values))\n                {\n                    this._target.eq(i).css(values);\n                }\n            }\n        }\n    };         \n    \n\n    /**\n     * Override TweenCommon._getRealEasing()\n     * It generates also custom bezier curves needed for resuming a paused tween honoring the original easing effect\n     * \n     * @param {string|array} value\n     * @returns {string|array|function}\n     */\n    this._getRealEasing = function(value)\n    {\n        if(isString(value) && value in easings)\n        {\n            value = easings[value];\n        }\n\n        if(isArray(value))\n        {\n            var position = this._position;\n            // in backward direction, reverse the bezier curve too\n            if(!this._localFwd)\n            {\n                value = reverseBezier(value);\n                position = this._duration - position;\n            }\n\n            var timeRatio = position / this._duration;\n            value = this._getBezierEasing(getNewBezier(value, timeRatio));\n        }\n\n        return value;\n    };\n\n\n};","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n\n/**\n * Vars and methods used in timeline object, for animation library that does not have native support for timelines\n * @mixin\n *\n */\nvar TimelinePro = function()\n{\n    this._emulatedPlayhead = true;\n\n    this._emulatedBegin = true;\n\n    this._emulatedProgress = true;\n\n    this._runningList = {};\n\n    this._runningCount = 0;\n\n    this._keyframes = {};\n\n    this._index = [];\n\n    this._childrenList = [];\n\n    this._backKeyframes = {};\n\n    this._backIndex = [];\n\n    this._backEnabled = true;\n\n    this._keyTime = null;\n    this._keyDirection = null;\n    this._keyCurrentIndex = null;\n\n\n\n    /**\n     * Cascade a method call to the children that are currently running\n     *\n     * @param {string} method\n     * @returns {this}\n     */\n    this._propagate = function(method)\n    {\n        var args = toArray(arguments, 1);\n        for(var id in this._runningList)\n        {\n            this._runningList[id][method].apply(this._runningList[id], args);\n        }\n        return this;\n    };\n\n\n    /**\n     * Cascade a method call to the all the children, regardless their running status\n     *\n     * @param {string} method\n     * @returns {this}\n     */\n    this._propagateToAll = function(method)\n    {\n        var args = toArray(arguments, 1);\n        for(var i = 0, end = this._childrenList.length; i < end; i++)\n        {\n            this._childrenList[i][method].apply(this._childrenList[i], args);\n        }\n        return this;\n    };\n\n\n    /**\n     * Perform internal tasks needed before starting the timeline\n     *\n     * @returns {number} - Returns the timeline total duration\n     */\n    this.prepare = function()\n    {\n        if(this._ready)\n        {\n            return this;\n        }\n\n        var sortInt = function(a, b){\n            return a - b;\n        };\n\n        this._reset();\n\n        if(this._emulatedProgress)\n        {\n            this\n                .setCoreHandler('end', '_progress', this._stopProgress, this, [])\n                .setCoreHandler('reverse', '_progress', this._stopProgress, this, []);\n        }\n\n        this._mergeChildren();\n        this._index.sort(sortInt);\n\n        // empty timeline\n        if(!this._index.length)\n        {\n            this._ready = true;\n            return this;\n        }\n\n        var i = 1;\n        var firstTime = this._index[0];\n        // if the first child does not start at 0, add a dummy to fill to gap\n        if(firstTime !== 0)\n        {\n            // prevent the push of 0 at the end of index, because index is already sorted\n            this._keyframes[0] = {f: [], b: [], fTrigger: null, bTrigger: null};\n            this._addDummy(0, firstTime);\n            this._keyframes[0].bTrigger = null;\n            this._index.unshift(0);\n            i++;\n        }\n\n        // add dummies to fill the gaps between real children, in both directions, so the timeline will work like a queues tree\n        var time, keyframe, j;\n        for(var len = this._index.length - 1; i < len; i++)\n        {\n            time = this._index[i];\n            keyframe = this._keyframes[time];\n            if(!keyframe.bTrigger)\n            {\n                j = i - 1;\n                while(j > 0 && !this._keyframes[this._index[j]].bTrigger)\n                {\n                    j--;\n                }\n                this._addDummy(this._index[j], time);\n            }\n            if(!keyframe.fTrigger)\n            {\n                j = i + 1;\n                while(j < this._index.length - 2 && !this._keyframes[this._index[j]].fTrigger)\n                {\n                    j++;\n                }\n                this._addDummy(time, this._index[j]);\n            }\n        }\n\n        this._backIndex.sort(sortInt);\n        this._ready = true;\n        return this._getTotalDuration();\n    };\n\n\n    /**\n     * Push child to the top level timeline in order to build a sorted index needed for restarting all the tweens in the right order\n     *\n     * @param {object} tween\n     * @param {number} begin\n     * @param {number} end\n     * @param {number} offset\n     * @returns {this}\n     */\n    this.pushUp = function(tween, begin, end, offset)\n    {\n        if(this._parent)\n        {\n            this._parent.pushUp(tween, begin + offset, end + offset, 0);\n        }\n        else\n        {\n            if(tween.type == 'tween')\n            {\n                tween.offset(begin + offset);\n            }\n        }\n\n        // add to backIndex\n        this._addToIndex(tween, begin, end, false, false, true);\n        return this;\n    };\n\n\n    /**\n     * Reset internal indexes and properties, needed by invalidate()\n     *\n     */\n    this._reset = function()\n    {\n        this._offset = 0;\n        this._cursor = null;\n        this._keyframes = {};\n        this._index = [];\n        this._backKeyframes = {};\n        this._backIndex = [];\n    };\n\n\n    /**\n     * Add a dummy child. Dummies are needed to fill gaps between real children.\n     * Dummy reverse and end events will trigger the start for other children\n     *\n     * @param {number} begin\n     * @param {number} end\n     */\n    this._addDummy = function(begin, end)\n    {\n        var dummy = this._getDummy();\n        var res = this._addToIndex(dummy, begin, end, true, true, false);\n        this.pushUp(dummy, begin, end);\n        dummy\n            .parent(this)\n            .duration(end - begin)\n            .setCoreHandler('reverse', 'timeline', this._childCallback, this, ['b', begin, dummy.id(), res[0]])\n            .setCoreHandler('end', 'timeline', this._childCallback, this, ['f', end, dummy.id(), res[1]]);\n\n        this._childrenList.push(dummy);\n    };\n\n\n    /**\n     * Save a children to index or backIndex. Indexes are needed to start and reset tweens in the right order\n     *\n     * @param {object} tween - dummy, tween or timeline object\n     * @param {number} begin\n     * @param {number} end\n     * @param {boolean} fTriggering - forward triggering, true when this child is suitable for triggering next children with its end event\n     * @param {boolean} bTriggering - backward triggering, true when this child is suitable for triggering previous children with its reverse event\n     * @param {boolean} useBack - true = store data in backIndex\n     * @returns {array}\n     */\n    this._addToIndex = function(tween, begin, end, fTriggering, bTriggering, useBack)\n    {\n        var keyframes, index, firstBegin, firstEnd;\n        if(useBack)\n        {\n            keyframes = this._backKeyframes;\n            index = this._backIndex;\n        }\n        else\n        {\n            keyframes = this._keyframes;\n            index = this._index;\n        }\n\n        if(!(begin in keyframes))\n        {\n            keyframes[begin] = {f: [], b: [], fc: [], bc: [], fTrigger: null, bTrigger: null};\n            index.push(begin);\n        }\n        if(tween.type == 'callback')\n        {\n            keyframes[begin].fc.push(tween);\n        }\n        else\n        {\n            keyframes[begin].f.push(tween);\n        }\n        // use only one child for each keyframe trigger in forward direction\n        firstBegin = fTriggering && !this._keyframes[begin].fTrigger;\n        if(firstBegin)\n        {\n            keyframes[begin].fTrigger = tween;\n        }\n\n        if(end != Infinity)\n        {\n            if(!(end in keyframes))\n            {\n                keyframes[end] = {f: [], b: [], fc: [], bc: [], fTrigger: null, bTrigger: null};\n                index.push(end);\n            }\n            if(tween.type == 'callback')\n            {\n                keyframes[end].bc.push(tween);\n            }\n            else\n            {\n                keyframes[end].b.push(tween);\n            }\n            // use only one child for each keyframe trigger in backward direction\n            firstEnd = bTriggering && !this._keyframes[end].bTrigger;\n            if(firstEnd)\n            {\n                keyframes[end].bTrigger = tween;\n            }\n        }\n\n        return [firstBegin, firstEnd];\n    };\n\n\n    /**\n     * Available for drivers that need to perform extra operation with labels\n     *\n     * @param {object} child - Label object\n     * @param {number} begin - label position inside the timeline\n     */\n    this._mergeLabel = function(child, begin)\n    {\n        // nop\n    };\n\n\n    /**\n     * Merge tweens and timelines inside their parent timeline\n     *\n     * @param {object} child - tween or timeline\n     * @param {number} begin\n     * @param {number} end\n     */\n    this._mergeTweenable = function(child, begin, end)\n    {\n        this._childrenList.push(child);\n        this._mergeElement(child, begin, end, true);\n    };\n\n\n    /**\n     * Merge callbacks inside their parent timeline\n     *\n     * @param {object} child - Callback object\n     * @param {number} begin\n     * @param {number} end\n     */\n    this._mergeCallback = function(child, begin, end)\n    {\n        this._mergeElement(child, begin, end, false);\n    };\n\n\n    /**\n     * Finalize the merging of tweens, timelines and callbacks\n     *\n     * @param {object} child\n     * @param {number} begin\n     * @param {number} end\n     * @param {boolean} tweenable - true for tweens and timelines\n     * @returns {undefined}\n     */\n    this._mergeElement = function(child, begin, end, tweenable)\n    {\n        // trigger will be true only for tweenable children with positive duration (callbacks have end = begin)\n        var trigger = end > begin;\n        var res = this._addToIndex(child, begin, end, trigger, trigger, false);\n\n        if(tweenable)\n        {\n            this.pushUp(child, begin, end, this._offset);\n\n            child.setCoreHandler('reverse', 'timeline', this._childCallback, this, ['b', begin, child.id(), res[0]]);\n            if(end != Infinity)\n            {\n                child.setCoreHandler('end', 'timeline', this._childCallback, this, ['f', end, child.id(), res[1]]);\n            }\n        }\n    };\n\n\n    /**\n     * Called by each child on reverse and end events. Used for update runningList and trigger the start of other previous or next children\n     *\n     * @param {string} direction - 'b' = backward | 'f' = forward\n     * @param {number} time\n     * @param {number} id - unique identifier of the child\n     * @param {boolean} isKeyChild - true when the child is enabled to trigger the start of other children\n     */\n    this._childCallback = function(direction, time, id, isKeyChild)\n    {\n        // remove from runningList\n        if(id in this._runningList)\n        {\n            delete this._runningList[id];\n            this._runningCount--;\n        }\n\n        if(isKeyChild)\n        {\n            if(time in this._keyframes)\n            {\n                this._processKeyframe(time, direction, null);\n            }\n        }\n    };\n\n\n\n    this._processKeyframe = function(time, direction, currentIndex)\n    {\n        this._keyCurrentIndex = null;\n\n        var cDirection = direction + 'c', cList = this._keyframes[time][cDirection], tList = this._keyframes[time][direction],\n            i, end, offset, item, paused = false;\n\n        if(cList.length)\n        {\n            if(direction == 'f')\n            {\n                i = currentIndex !== null? currentIndex + 1 : 0;\n                end = cList.length;\n                offset = 1;\n            }\n            else\n            {\n                i = currentIndex !== null? currentIndex - 1 : cList.length - 1;\n                end = -1;\n                offset = -1;\n            }\n\n            for(; i != end; i += offset)\n            {\n                item = cList[i];\n                if(item.isPause)\n                {\n                    paused = true;\n                    this._keyTime = time;\n                    this._keyDirection = direction;\n                    this._keyCurrentIndex = i;\n                    this.pause();\n                }\n\n                // also callback are executed by resume()\n                item.resume();\n                if(paused)\n                {\n                    break;\n                }\n            }\n        }\n\n        if(!paused)\n        {\n            if(tList.length)\n            {\n                for(i = 0, end = tList.length; i < end; i++)\n                {\n                    item = tList[i];\n                    this._addToRun(item);\n                    item.resume();\n                }\n            }\n            // emulate end / reverse events\n            if((direction == 'b' && time === 0) || (direction == 'f' && time == this._index[this._index.length - 1]))\n            {\n                this._runHandlers('_end');\n            }\n        }\n\n        return paused;\n    };\n\n\n    /**\n     * Called on first timeline start\n     *\n     * @returns {this}\n     */\n    this._run = function()\n    {\n        this._running = true;\n        this._delayDummy = null;\n\n        if(this._emulatedBegin && this._hasHandlers('_begin'))\n        {\n            this._runHandlers('_begin');\n        }\n\n        this._startTime = Tw.ticker.now();\n        this._playTween();\n\n        return this;\n    };\n\n\n    /**\n     * trigger the start of the first keyframe\n     *\n     */\n    this._playTween = function()\n    {\n        this._childCallback('f', 0, -1, true);\n    };\n\n\n    /**\n     * propagate pause to the running children\n     *\n     */\n    this._pauseTween = function()\n    {\n        this._propagate('pause');\n    };\n\n\n    /**\n     * if running, propagate resume to running children, else trigger first or last keyframe accordingly with current direction\n     */\n    this._resumeTween = function()\n    {\n        var runningCount = this._runningCount, paused = false;\n        this._startProgress();\n\n        if(this._keyCurrentIndex !== null)\n        {\n            this._keyDirection = this._localFwd? 'f' : 'b';\n            paused = this._processKeyframe(this._keyTime, this._keyDirection, this._keyCurrentIndex);\n        }\n\n        if(!paused)\n        {\n            if(runningCount)\n            {\n                this._propagate('resume');\n            }\n            else\n            {\n                var args = false, direction = this._localFwd;\n\n                if(direction && this._position === 0)\n                {\n                    args = ['f', 0, -1, true];\n                }\n                else if(!direction && this._position == this._duration)\n                {\n                    args = ['b', this._index.length? this._index[this._index.length - 1] : 0, -1, true];\n                }\n\n                if(args)\n                {\n                    this._childCallback.apply(this, args);\n                }\n            }\n        }\n    };\n\n\n    /**\n     * Go to final or start position resetting also the children, accordingly with current direction\n     *\n     */\n    this._backTween = function()\n    {\n        // clear running List\n        this._runningList = {};\n        this._runningCount = 0;\n\n        // timeline disable back in nested timelines when going back\n        if(!this._backEnabled)\n        {\n            return;\n        }\n        var i, end, inc, type, elemList, time;\n\n        // reset tweens in reverse order, in order to restore all the style properties correctly\n        if(this._localFwd)\n        {\n            i = this._backIndex.length - 1;\n            end = -1;\n            inc = -1;\n            type = 'f';\n        }\n        else\n        {\n            i = 0;\n            end = this._backIndex.length;\n            inc = 1;\n            type = 'b';\n        }\n\n\n        for(; i != end; i += inc)\n        {\n            time = this._backIndex[i];\n            elemList = this._backKeyframes[time][type];\n            for(var j = elemList.length - 1; j >= 0; j--)\n            {\n                var child = elemList[j];\n                // disable back in children timelines\n                child._backEnabled = false;\n                child.pause().back();\n                child._backEnabled = true;\n            }\n        }\n    };\n\n\n    /**\n     * Add child to runningList\n     *\n     * @param {object} child\n     * @returns {this}\n     */\n    this._addToRun = function(child)\n    {\n        if(child.totalDuration())\n        {\n            var id = child.id();\n            // avoid multiple wrong increments of runningCount\n            if(!(id in this._runningList))\n            {\n                this._runningCount ++;\n                this._runningList[id] = child;\n            }\n        }\n        return this;\n    };\n\n\n    /**\n     * Remove child from runningList\n     *\n     * @param {object} child\n     * @returns {this}\n     */\n    this._removeFromRun = function(child)\n    {\n        var id = child.id();\n        // avoid multiple wrong decrements of runningCount\n        if(id in this._runningList)\n        {\n            this._runningCount --;\n            delete this._runningList[id];\n        }\n        return this;\n    };\n};\n","/**\n * Tweene - JavaScript Animation Proxy \n * \n * @link http://tweene.com\n *   \n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n * \n * @license Artistic License 2.0 \n * See LICENSE.txt for details\n * \n */\n\n\n/**\n * Dummy tween driver. Dummies are used to emulate delay and to fill time gaps between real tweens inside timelines\n * @class\n * @mixes Common, TweenCommon, ControlsPro, TweenPro\n * \n * suitable OST https://www.youtube.com/watch?v=GaUqpnHvua8\n * \n */   \nTw.registerDriver('Dummy', 'tween', function() {\n    Common.call(this);\n    TweenCommon.call(this);\n    ControlsPro.call(this);\n    TweenPro.call(this);    \n\n    \n    this._driverTimeUnit = 'ms';    \n    this._emulatedPlayhead = true;\n    this._emulatedProgress = true;\n        \n    this\n        .setCoreHandler('end', 'resetPos', this._resetPosition, this)\n        .setCoreHandler('reverse', 'resetPos', this._resetPosition, this)\n        .setCoreHandler('end', '_progress', this._stopProgress, this)\n        .setCoreHandler('reverse', '_progress', this._stopProgress, this);                \n\n    \n    /**\n     * nothing to invalidate here\n     * \n     * @returns {this}\n     */\n    this.invalidate = function()\n    {\n        return this;\n    };\n    \n    \n    /**\n     * Override ControlsPro.pause()\n     * \n     * @returns {this}\n     */\n    this.pause = function()\n    {\n        if(!this._paused)\n        {\n            this._stopProgress();\n            // remove callback from ticker queue\n            Tw.ticker.removeCallback(this._id);\n            this._paused = true;\n            this._pauseTime = Tw.ticker.now();\n            this._position += (this._pauseTime - this._startTime) * this.getRealSpeed() * (this._localFwd? 1 : -1);\n        }\n        return this;\n    };\n    \n                        \n    /** \n     * Set internal position of dummy\n     * \n     * @param {number} value\n     * @returns {this}\n     */      \n    this.position = function(value)\n    {\n        this._position = value;\n        if(value === 0)\n        {\n            this._playAllowed = true;\n        }\n        else if(value == this._duration)\n        {\n            this._reverseAllowed = true;\n        }\n            \n        return this;\n    };\n    \n    \n    /**\n     * Set dummy duration\n     * \n     * @param {number} value\n     * @returns {this}\n     */\n    this.duration = function(value)\n    {\n        this._duration = value;\n        return this;\n    };\n    \n    \n    /**\n     * Override ControlsPro.resume()\n     * \n     * @returns {this}\n     */\n    this.resume = function()\n    {\n        if(this._paused)\n        {\n            this._running = true;\n            this._paused = false;            \n            var handler = this._localFwd? 'end' : 'reverse';\n            \n            if(this._localFwd && this._position === 0)\n            {\n                this._runHandlers('begin');                \n            }\n            var duration = (this._localFwd? this._duration - this._position : this._position) / this.getRealSpeed();                \n            if(!duration)\n            {\n                this._runHandlers(handler);\n            }\n            else\n            {                \n                var params = [duration, this._id, this._runHandlers, this, [handler]];\n                this._startTime = Tw.ticker.now();\n                // add callback in ticker queue\n                Tw.ticker.addCallback.apply(Tw.ticker, params);                \n                this._startProgress();\n            }\n        }\n        return this;\n    };\n    \n        \n    this._backTween = function() {};    \n        \n});\n      \n","/**\n * Tweene - JavaScript Animation Proxy\n *\n * @link http://tweene.com\n *\n * Copyright (c) 2014, Federico Orru'   <federico@buzzler.com>\n *\n * @license Artistic License 2.0\n * See LICENSE.txt for details\n *\n */\n\n\n/**\n * Transit Tween Driver\n *\n * @link http://ricostacruz.com/jquery.transit/ *\n * @mixes Common, TweenCommon, ControlsPro, TweenPro\n *\n */\nTw.registerDriver('transit', 'tween', function() {\n    Common.call(this);\n    TweenCommon.call(this);\n    ControlsPro.call(this);\n    TweenPro.call(this);\n\n    this._driverTimeUnit = 'ms';\n\n    this._emulatedPlayhead = true;\n    this._emulatedFrom = true;\n    this._emulatedDelay = true;\n    this._emulatedLoop = true;\n    this._emulatedBegin = true;\n    this._emulatedProgress = true;\n    this._allowTransform = true;\n    this._allowMultipleEasing = false;\n\n    this._propertyMap = {\n        translateX: 'x',\n        translateY: 'y',\n        translateZ: 'z',\n        rotateZ: 'rotate',\n        rotation: 'rotate',\n        rotationX: 'rotateX',\n        rotationY: 'rotateY',\n        rotationZ: 'rotate',\n        scaleZ: 'scale'\n    };\n\n    // force transitionEnd events\n    $.transit.useTransitionEnd = true;\n\n    this._emulatingComplete = false;\n    this._currentEasing = null;\n\n    this._styles = [];\n    this._firstRun = true;\n    this._rotationFixed = false;\n\n\n    /**\n     * Get style objects for a dom target, storing the reference inside an internal cache\n     *\n     */\n    this._getTargetStyle = function(i, useStyle)\n    {\n        // style are checked in asc order\n        if(i >= this._styles.length)\n        {\n            var target = this._target.get(i);\n            this._styles[i] = [window.getComputedStyle(target), target.style];\n        }\n\n        return this._styles[i][useStyle? 1 : 0];\n    };\n\n\n    /**\n     * CSS Transitions supports natively cubic bezier curves\n     *\n     * @param {array} value\n     * @returns {string}\n     */\n    this._getBezierEasing = function(value)\n    {\n        if(this._currentEasing === null)\n        {\n            this._currentEasing = value;\n        }\n        return 'cubic-bezier(' + value.join(', ') + ')';\n    };\n\n\n    /**\n     * Fetch transform property value directly from Transit\n     *\n     */\n    this._getTransformValue = function(target, name, raw)\n    {\n        var transform = target.data('transform');\n        if(!transform || !(name in transform))\n        {\n            if(raw)\n            {\n                return null;\n            }\n            else\n            {\n                if(name.indexOf('scale') === 0)\n                {\n                    name = 'scale';\n                }\n                else if(name.indexOf('rotate') === 0)\n                {\n                    name = 'rotate';\n                }\n            }\n        }\n        return target.css(name);\n    };\n\n\n    /**\n     * Fetch current style properties values and pass them to the given callback\n     *\n     * @param {object} target\n     * @param {object} tween\n     * @param {boolean} useStyle\n     * @param {function} callback\n     *\n     */\n    this._getCurrentValues = function(target, tween, useStyle, callback)\n    {\n        var item = target.get(0), name, value, property;\n        var style = useStyle? item.style : window.getComputedStyle(item);\n\n        for(name in tween)\n        {\n            if(tween[name].isTransform)\n            {\n                value = this._getTransformValue(target, name);\n            }\n            else\n            {\n                property = getProperty(style, name);\n                // update data in case of browser-prefixed name\n                if(property[0] != name)\n                {\n                    tween[property[0]] = tween[name];\n                    delete tween[name];\n                    name = property[0];\n                }\n                value = property[1];\n            }\n\n            if(value !== void 0)\n            {\n                callback.call(this, tween, name, value);\n            }\n        }\n    };\n\n\n    /**\n     * Save pre-start values in tween structure\n     *\n     * @param {object} tween\n     * @param {string} name\n     * @param {string|number} value\n     */\n    this._fetchBeginPre = function(tween, name, value)\n    {\n        var prop = tween[name];\n        prop.pre = value;\n        if(!this._hasEnd)\n        {\n            prop.end = value;\n            if(this._hasThen && prop.then === null)\n            {\n                prop.then = value;\n            }\n        }\n        this._hasPre = true;\n    };\n\n\n    /**\n     * Save post-start values in tween structure\n     *\n     * @param {object} tween\n     * @param {string} name\n     * @param {string|number} value\n     */\n    this._fetchBeginPost = function(tween, name, value)\n    {\n        var prop = tween[name];\n        prop.begin = value;\n        if(prop.end === null)\n        {\n            prop.end = value;\n            if(this._hasThen && prop.then === null)\n            {\n                prop.then = value;\n            }\n        }\n    };\n\n\n    /**\n     * Save values after applying 'then' style\n     *\n     * @param {object} tween\n     * @param {string} name\n     * @param {string|number} value\n     */\n    this._fetchThen = function(tween, name, value)\n    {\n        tween[name].then = value;\n    };\n\n\n    /**\n     * Save pre-tween values in tween structure\n     *\n     * @param {object} tween\n     * @param {string} name\n     * @param {string|number} value\n     */\n    this._fetchPlayPre = function(tween, name, value)\n    {\n        var prop = tween[name];\n        prop.begin = value;\n\n        if(prop.end === null)\n        {\n            prop.end = value;\n        }\n\n        if(this._hasThen && prop.then === null)\n        {\n            prop.then = value;\n        }\n    };\n\n\n    /**\n     * Save post-tween values in tween structure\n     *\n     * @param {object} tween\n     * @param {string} name\n     * @param {string|number} value\n     */\n    this._fetchPlayPost = function(tween, name, value)\n    {\n        var prop = tween[name];\n        prop.end = value;\n\n        if(this._hasThen && prop.then === null)\n        {\n            prop.then = value;\n        }\n\n    };\n\n\n    /**\n     * Set css values instantly\n     *\n     * @param {string} field - 'begin' | 'end' | 'pre' | 'then'\n     */\n    this._setTween = function(field)\n    {\n        var tween, target, i, end;\n        for(i = 0, end = this._target.length; i < end; i++)\n        {\n            tween = this._data.tween[i];\n            target = this._target.eq(i);\n\n            if(field == 'begin' && this._hasBegin && !this._beginReady)\n            {\n                this._getCurrentValues(target, tween, false, this._fetchBeginPre);\n            }\n\n            var values = this._getTweenValues(tween, field, true);\n            this._target.eq(i).css(values);\n\n            if(field == 'begin' && this._hasBegin && !this._beginReady)\n            {\n                this._getCurrentValues(target, tween, false, this._fetchBeginPost);\n            }\n            else if(field == 'then' && this._hasThen && !this._thenReady)\n            {\n                this._getCurrentValues(target, tween, false, this._fetchThen);\n            }\n        }\n\n        if(field == 'begin')\n        {\n            this._beginReady = true;\n        }\n        else if(field == 'then')\n        {\n            this._thenReady = true;\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Execute the effective tween\n     *\n     */\n    this._playTween = function()\n    {\n        var data = this._data,\n            self = this, useTrans = data.duration > 0,\n            method = useTrans? 'transition' : 'css',\n            field = this._localFwd? 'end' : 'begin',\n            name, needRepaint, item, targetStyle, targetComputedStyle, posValue,\n            posNames = ['left', 'top', 'right', 'bottom'], pos,\n            i, end, j, endj, values, nop,\n            onComplete = function(event) {\n                //event.stopPropagation();\n                //event.preventDefault();\n//                if(this == event.target)\n//                {\n                    self._target.css('transition', 'none');\n                    self._runHandlers('_end');\n//                    Tw.ticker.addCallback(-1, '-' + self._id, self._runHandlers, self, ['_end']);\n//                }\n//                else\n//                {\n//                    console.log('parent!');\n//                }\n                return false;\n            };\n\n        for(i = 0, end = this._target.length; i < end; i++)\n        {\n            var tween = data.tween[i];\n            var target = this._target.eq(i);\n            if(!this._beginReady)\n            {\n                this._getCurrentValues(target, tween, false, this._fetchPlayPre);\n            }\n\n            values = this._getTweenValues(tween, field, false);\n\n            // use transitions only if duration > 0\n            if(useTrans)\n            {\n                values.duration = data.realDuration;\n                values.queue = false;\n                if(data.duration)\n                {\n                    values.easing = this._getRealEasing(data.easing);\n                }\n\n                // on first run there could be a bug when animating left, top, right or bottom that are 'auto', we need to force a repaint\n                if(this._firstRun)\n                {\n                    needRepaint = false;\n                    targetStyle = null;\n                    targetComputedStyle = null;\n                    item = target.get(0);\n\n                    for(j = 0, endj = posNames.length; j < endj; j++)\n                    {\n                        pos = posNames[j];\n                        if(pos in values)\n                        {\n                            // target style cached while checking all the properties\n                            if(!targetStyle)\n                            {\n                                targetStyle = this._getTargetStyle(i, true);\n                                targetComputedStyle = this._getTargetStyle(i, false);\n                            }\n                            posValue = targetStyle[pos];\n                            // if 'auto', use value from jquery position(), else use computed value, then force a repaint\n                            if(posValue === '' || posValue === 'auto')\n                            {\n                                targetStyle[pos] = targetComputedStyle[pos] == 'auto'? target.position()[pos] : targetComputedStyle[pos];\n                                needRepaint = true;\n                            }\n                        }\n                    }\n                    if(needRepaint)\n                    {\n                        nop = item.offsetWidth;\n                    }\n\n                }\n            }\n            if(useTrans && i == end - 1)\n            {\n                // transit complete callback is not passing the event object needed to stop propagation in nested contexts\n                // also when display = none, css transitions does not raise complete event\n                // we need to emulate the event\n                this._emulatingComplete = true;\n                Tw.ticker.addCallback(data.realDuration, '-emulate' + this._id, onComplete);\n                target.transition(values);\n                target.unbind('transitionend');\n            }\n            else\n            {\n                target[method](values);\n            }\n\n            if(!this._endReady)\n            {\n                this._getCurrentValues(target, tween, true, this._fetchPlayPost);\n            }\n        }\n\n        this._firstRun = false;\n        this._beginReady = true;\n        this._endReady = true;\n\n        // if instant tween, emulate complete event\n        if(!useTrans)\n        {\n            this._runHandlers('_end');\n        }\n\n        return this;\n    };\n\n\n    /**\n     * Pause a running tween\n     *\n     */\n    this._pauseTween = function()\n    {\n        var easingFunc = null, transform, transformValues = null, offset, currentOffset,\n            timeProgress, valueProgress, beginValue, endValue, current,\n            i, end, style, targetStyle, tween, target, name, prop;\n\n        // cancel complete callback\n        if(this._emulatingComplete)\n        {\n            Tw.ticker.removeCallback('-emulate' + this._id);\n        }\n        this._target.unbind($.support.transitionEnd);\n\n        for(i = 0, end = this._target.length; i < end; i++)\n        {\n            style = {};\n            targetStyle = this._getTargetStyle(i, false);\n            tween = this._data.tween[i];\n            target = this._target.eq(i);\n            for(name in tween)\n            {\n                prop = tween[name];\n                if(prop.isTransform)\n                {\n                    // fetch current transition values directly from transform matrix, no need for calculation\n                    if(name == 'x' || name == 'y' || name == 'z')\n                    {\n                        if(!transformValues)\n                        {\n                            transform = getProperty(targetStyle, 'transform')[1];\n                            transformValues = transform.substring(transform.indexOf('(') + 1, transform.length - 1).split(/\\s*,\\s*/);\n                            offset = transform.indexOf('matrix3d') === 0? 12 : 4;\n                        }\n                        currentOffset = offset + (name == 'z'? 2 : (name == 'y'? 1 : 0));\n                        style[name] = transformValues[currentOffset];\n                    }\n                    else\n                    {\n                        // calculate the current value at current progress, taking easing in consideration\n                        if(!easingFunc)\n                        {\n                            easingFunc = bezier.apply(null, this._currentEasing);\n                            timeProgress = this.progress();\n                            valueProgress = easingFunc(timeProgress);\n                        }\n                        beginValue = parseFloat(prop.begin);\n                        endValue = parseFloat(prop.end);\n                        current = ((endValue - beginValue) * valueProgress) + beginValue;\n                        style[name] = current;\n                    }\n                }\n                else\n                {\n                    // read non-transform properties directly from computed style\n                    style[name] = targetStyle[name];\n                }\n            }\n            style[getProperty(targetStyle, 'transition')[0]] = 'none';\n            target.css(style);\n        }\n        return this;\n    };\n\n\n\n    this._resumeTween = function()\n    {\n        return this._playTween();\n    };\n\n\n});\n\n\n\n/**\n * Transit Timeline Driver\n *\n * @mixes Common, TimelineCommon, ControlsPro, TimelinePro\n *\n */\nTw.registerDriver('transit', 'timeline', function() {\n    Common.call(this);\n    TimelineCommon.call(this);\n    ControlsPro.call(this);\n    TimelinePro.call(this);\n\n    this._driverTimeUnit = 'ms';\n\n});\n\nTw.defaultTimeUnit = 'ms';\nTw.defaultDriver = 'transit';\n"],"sourceRoot":"/source/"}